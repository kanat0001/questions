[

  {
    "id": "js-001",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между var, let и const?",
    "answer": "В JavaScript переменные можно объявлять через `var`, `let` и `const`, но они отличаются областью видимости, hoisting и правилами повторного объявления.\n\n- **`var`** — имеет **функциональную область видимости** (не блочную). При hoisting объявление поднимается вверх и **сразу инициализируется `undefined`**, поэтому к переменной можно обратиться до строки объявления, но получишь `undefined`. Разрешает **переобъявление в той же области**, из-за чего легко словить баги.\n\n- **`let`** — имеет **блочную область видимости**. Тоже поднимается (hoisting есть), но до инициализации находится в **TDZ**, поэтому обращение до строки объявления даст **ReferenceError**. **Повторно объявить нельзя**, но **переназначать значение можно**.\n\n- **`const`** — как `let` по scope и TDZ, но **нельзя переназначить ссылку**. При этом **объекты/массивы можно мутировать**, потому что меняется содержимое, а не ссылка."
  },
  {
    "id": "js-002",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Temporal Dead Zone?",
    "answer": "Temporal Dead Zone (TDZ) — это промежуток времени в пределах блока, когда переменная `let/const` уже **создана** (движок знает о ней), но ещё **не инициализирована**.\n\nПроще: с начала блока `{ ... }` и до строки, где выполнится `let a = ...`, переменная `a` находится в TDZ. Если попытаться обратиться к ней в этот момент, будет **ReferenceError**.\n\nTDZ существует, чтобы предотвратить использование переменной «до объявления» и сделать код предсказуемее (в отличие от `var`, который даёт `undefined`)."
  },
  {
    "id": "js-003",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое hoisting и что именно хойстится?",
    "answer": "Hoisting — это механизм JavaScript, при котором объявления переменных и функций поднимаются в начало области видимости до выполнения кода. Это нужно для того, чтобы движок заранее знал о существовании переменных и функций и мог корректно построить область видимости перед выполнением кода."
  },
  {
    "id": "js-004",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между function declaration и function expression?",
    "answer": "Function Declaration — это способ объявления функции через ключевое слово function, при котором функция полностью поднимается в начало области видимости и может быть вызвана до её объявления. Function Expression — это функция, присвоенная переменной. Она не поднимается как функция и доступна только после объявления переменной."
  },
  {
    "id": "js-005",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему функции — объекты?",
    "answer": "«В JavaScript функции — это вызываемые объекты (Callable Objects). Они являются объектами первого класса, так как наследуются от глобального конструктора Object через цепочку прототипов (Function.prototype -> Object.prototype). Технически это обычные объекты, у которых есть дополнительный скрытый метод [[Call]], позволяющий выполнять код внутри функции при обращении через круглые скобки».Почему это важно (суть): Если бы функции не были объектами, мы не могли бы: Передавать их в другие функции как переменные (Callback). Вешать на них методы (как в jQuery или библиотеках валидации). Создавать из них конструкторы через new."
  },
  {
    "id": "js-006",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое область видимости (scope)?",
    "answer": "область видимости — это просто «зона действия» переменной. Это правила, которые определяют, где в коде мы можем использовать конкретную переменную, а где она «не существует». Иерархия (Матрешка): Поиск переменной всегда идет снизу вверх. Если функции нужна переменная, она сначала ищет её у себя внутри. Не нашла? Идет искать в ту функцию, внутри которой она написана. И так до самого верха — до глобальной области. Лексичность: Это самое важное. Область видимости фиксируется в момент, когда ты пишешь код, а не когда ты его запускаешь. Функция навсегда запоминает то место, где она была создана, и «видит» переменные, которые были вокруг неё в тот момент."
  },
  {
    "id": "js-007",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое lexical environment?",
    "answer": "Lexical Environment — это внутреннее окружение выполнения, которое хранит текущие переменные и ссылку на внешнее окружение. Благодаря этому JavaScript реализует лексическую область видимости. Если чуть глубже: Каждый вызов функции создаёт новый lexical environment, содержащий свои переменные и ссылку на родительское окружение, что позволяет реализовать цепочку областей видимости (scope chain)."
  },
  {
    "id": "js-008",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что хранится в call stack?",
    "answer": "Call Stack — это структура данных, которая хранит контексты выполнения вызываемых функций. Каждый вызов функции помещается в стек и удаляется после завершения. Если чуть глубже: В Call Stack хранятся execution context'ы функций: их переменные, параметры и информация о текущем месте выполнения кода."
  },
  {
    "id": "js-009",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает цепочка областей видимости (scope chain)?",
    "answer": "Scope chain — это механизм поиска переменных, при котором JavaScript сначала ищет переменную в текущей области видимости, затем во внешней и так далее до глобальной области. Если чуть глубже: Scope chain формируется через lexical environment: каждый execution context содержит ссылку на внешнее окружение, благодаря чему создаётся цепочка областей видимости."
  },
  {
    "id": "js-010",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему typeof null === object ?",
    "answer": "Это историческая особенность JavaScript (по сути баг), которая тянется с самых ранних версий языка. В первых реализациях значения имели внутренние «теги» типов, и у `null` оказался тег, который совпал с `object`. Поэтому оператор `typeof` возвращает Исправить это нельзя без поломки огромного количества старого кода, поэтому поведение закрепили ради обратной совместимости."
  },
  {
    "id": "js-011",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Какие есть примитивные типы в JavaScript?",
    "answer": "В JavaScript существует 7 примитивных типов: string, number, boolean, null, undefined, symbol и bigint. Примитивы хранятся по значению и являются неизменяемыми. Все остальные типы в JavaScript являются объектами."
  },
  {
    "id": "js-012",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое boxing?",
    "answer": "Boxing — это автоматическое временное преобразование примитивного значения в объект-обёртку, чтобы можно было использовать методы и свойства. Если чуть глубже: При обращении к методу примитива JavaScript создаёт соответствующий объект-обёртку (например, String), выполняет операцию и затем удаляет его."
  },
  {
    "id": "js-013",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между == и ===?",
    "answer": "== выполняет сравнение с приведением типов, а === сравнивает значения без приведения типов и требует совпадения типа и значения."
  },
  {
    "id": "js-014",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое неявное приведение типов?",
    "answer": "Неявное приведение типов — это автоматическое преобразование одного типа данных в другой, которое JavaScript выполняет во время операций или сравнений. Оно происходит при арифметических операциях, сравнении через ==, логических операциях и других выражениях."
  },
  {
    "id": "js-015",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что вернет [] + {} и почему?",
    "answer": "[] + {} вернёт строку [object Object], потому что оператор + приводит операнды к примитивам. Массив превращается в пустую строку через toString(), объект — в [object Object], после чего происходит строковая конкатенация."
  },
  {
    "id": "js-016",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что вернет {} + []?",
    "answer": "{} + [] в начале строки интерпретируется как пустой блок и унарный плюс, поэтому результат — 0. Если же выражение обернуть в скобки, оно вернёт строку [object Object] из-за приведения объектов к примитивам."
  },
  {
    "id": "js-017",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему NaN !== NaN?",
    "answer": "NaN !== NaN, потому что по стандарту IEEE 754 значение NaN не равно ничему, даже самому себе. Поэтому для проверки используется Number.isNaN()."
  },
  {
    "id": "js-018",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как правильно проверить значение на NaN?",
    "answer": "Проверять значение на NaN нужно через Number.isNaN(), потому что обычное сравнение не работает, а глобальный isNaN() выполняет неявное приведение типов."
  },
  {
    "id": "js-019",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между null и undefined?",
    "answer": "undefined означает, что значение не было присвоено, а null — это намеренно установленное пустое значение. Они равны при нестрогом сравнении, но имеют разные типы. undefined обычно устанавливается движком автоматически, а null присваивается разработчиком явно."
  },
  {
    "id": "js-020",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое falsy значения?",
    "answer": "Falsy значения — это значения, которые при приведении к Boolean дают false. В JavaScript их восемь: false, 0, -0, 0n, пустая строка, null, undefined и NaN. Falsy значения участвуют в неявном приведении типов в логических операциях и условиях."
  },

   {
    "id": "js-021",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое prototype?",
    "answer": "Prototype — это механизм наследования в JavaScript, при котором объект может получать доступ к свойствам и методам другого объекта через цепочку прототипов. Каждый объект содержит внутреннюю ссылку на свой прототип, и если свойство не найдено в самом объекте, поиск продолжается в прототипе."
  },
  {
    "id": "js-022",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает prototype chain?",
    "answer": "Prototype chain — это механизм поиска свойств, при котором JavaScript сначала проверяет сам объект, затем его прототип, затем прототип прототипа и так далее до null. Поиск осуществляется через внутреннюю ссылку [[Prototype]], формируя цепочку наследования."
  },
  {
    "id": "js-023",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между __proto__ и prototype?",
    "answer": "prototype — это свойство функции-конструктора, которое используется для создания прототипа новых объектов. __proto__ — это ссылка объекта на его прототип (внутренний [[Prototype]]). При создании объекта через new, его __proto__ указывает на Function.prototype соответствующего конструктора."
  },
  {
    "id": "js-024",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает Object.create()?",
    "answer": "Object.create() создаёт новый объект с указанным прототипом. Первый аргумент функции становится прототипом создаваемого объекта. Этот метод позволяет вручную управлять prototype chain без использования конструктора и оператора new."
  },
  {
    "id": "js-025",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое constructor?",
    "answer": "Constructor — это функция, которая используется для создания объектов через оператор `new`.Когда вызывается `new`:) создаётся пустой объект;) ему устанавливается прототип из `constructor.prototype`;) вызывается функция-конструктор с this, указывающим на новый объект) если явно не возвращён объект — возвращается созданный экземпляр.У каждого объекта есть свойство `constructor`, указывающее на функцию, которая его создала если цепочка не была изменена."
  },
  {
    "id": "js-026",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое hasOwnProperty?",
    "answer": "hasOwnProperty — это метод объекта, который проверяет, принадлежит ли свойство самому объекту, а не получено через prototype chain. Это важно, потому что при переборе свойств, например через for...in, мы можем получить и унаследованные свойства. Поэтому hasOwnProperty позволяет отфильтровать только собственные свойства объекта."
  },
  {
    "id": "js-027",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между shallow copy и deep copy?",
    "answer": "Shallow copy копирует только первый уровень объекта, а вложенные объекты остаются ссылками. Deep copy создаёт полностью независимую копию со всеми вложенными структурами. Это важно при работе с иммутабельными данными, чтобы избежать случайной мутации исходного объекта."
  },
  {
    "id": "js-028",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает spread в объектах?",
    "answer": "Оператор spread (`...`) в объектах создаёт поверхностную копию свойств.\n\nОн перебирает **enumerable собственные свойства** объекта и копирует их в новый объект.\n\nВажно: spread делает **shallow copy**. Вложенные объекты не клонируются, а передаются по ссылке."
  },
  {
    "id": "js-029",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое enumerable свойства?",
    "answer": "Enumerable свойства — это свойства объекта, которые участвуют в переборе. Если у свойства флаг enumerable установлен в true, оно будет доступно через for...in или Object.keys(). Если false — свойство существует, но не отображается при переборе. Этот механизм используется для контроля видимости свойств при итерации."
  },
  {
    "id": "js-030",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое property descriptor?",
    "answer": "Property descriptor — это объект, который описывает настройки свойства объекта: его значение, возможность изменения, перечисления и удаления. Дескрипторы используются для тонкой настройки поведения свойств через Object.defineProperty(). В JavaScript каждое свойство имеет внутренние атрибуты, которые управляют его поведением, и именно их описывает property descriptor."
  },

   {
    "id": "js-031",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое замыкание?",
    "answer": "Замыкание — это функция, которая запоминает лексическое окружение, в котором была создана.\n\nЭто значит, что даже после завершения внешней функции внутренняя функция продолжает иметь доступ к её переменным.\n\nЗамыкание возникает каждый раз, когда функция создаётся внутри другой функции и использует внешние переменные."
  },
  {
    "id": "js-032",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где замыкания реально используются?",
    "answer": "Замыкания используются для:\n\n- создания приватных переменных;\n- сохранения состояния между вызовами;\n- фабрик функций;\n- работы с асинхронностью (setTimeout, обработчики событий);\n- реализации memoization и debounce.\n\nФактически замыкания — это фундаментальный механизм работы React-хуков и большинства функциональных паттернов."
  },
  {
    "id": "js-033",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Пример утечки памяти через замыкание?",
    "answer": "Утечка возникает, если замыкание удерживает ссылку на большой объект, который больше не нужен.\n\nНапример: если обработчик события замыкает DOM-элемент или большой массив, и этот обработчик не удаляется, сборщик мусора не сможет освободить память.\n\nПроблема не в замыкании как таковом, а в том, что оно удерживает ссылки на данные, которые могли бы быть удалены."
  },
  {
    "id": "js-034",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое IIFE?",
    "answer": "IIFE (Immediately Invoked Function Expression) — это функция, которая создаётся и сразу же вызывается.\n\nПример концепции: функция оборачивается в скобки и тут же выполняется.\n\nИспользуется для создания изолированной области видимости и предотвращения загрязнения глобального пространства. До появления модулей это был основной способ изоляции кода."
  },
  {
    "id": "js-035",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое currying?",
    "answer": "Currying — это преобразование функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент.\n\nВместо `fn(a, b, c)` получаем `fn(a)(b)(c)`.\n\nЭто позволяет частично применять аргументы и создавать более специализированные функции."
  },
  {
    "id": "js-036",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое pure функция?",
    "answer": "Pure функция — это функция, которая:\n\n1) всегда возвращает одинаковый результат при одинаковых входных данных;\n2) не имеет побочных эффектов (не изменяет внешние переменные, DOM, состояние).\n\nТакие функции предсказуемы и проще тестируются."
  },
  {
    "id": "js-037",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое memoization?",
    "answer": "Memoization — это техника оптимизации, при которой результат функции сохраняется, чтобы при повторном вызове с теми же аргументами не выполнять вычисления заново.\n\nРаботает через замыкание: создаётся кэш, который хранит результаты предыдущих вызовов."
  },
  {
    "id": "js-038",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между rest и arguments?",
    "answer": "`arguments` — это псевдомассив всех переданных аргументов (доступен только в обычных функциях, не в стрелочных).\n\n`rest` (`...args`) — это современный синтаксис, который собирает аргументы в настоящий массив.\n\nRest предпочтительнее, потому что он более предсказуем и поддерживает методы массива."
  },
  {
    "id": "js-039",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое higher-order function?",
    "answer": "Higher-order function — это функция, которая:\n\n- принимает другую функцию как аргумент, или\n- возвращает функцию.\n\nПримеры: `map`, `filter`, `reduce`.\n\nЭто основа функционального программирования в JavaScript."
  },
  {
    "id": "js-040",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как реализовать debounce?",
    "answer": "Debounce — это функция-обёртка, которая откладывает выполнение до тех пор, пока не пройдёт заданное время без новых вызовов.\n\nРаботает через замыкание и `setTimeout`: при каждом вызове предыдущий таймер очищается, и запускается новый.\n\nИспользуется для оптимизации ввода в поиске, resize-событий и других частых вызовов."
  },
    {
    "id": "js-041",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "От чего зависит значение this?",
    "answer": "Значение `this` определяется способом вызова функции, а не местом её объявления.\n\nОсновные правила:\n1) Обычный вызов — `this` равен `undefined` в strict mode или глобальному объекту вне strict mode.\n2) Вызов как метода — `this` указывает на объект слева от точки.\n3) Через `call`, `apply`, `bind` — `this` равен переданному объекту.\n4) При `new` — `this` указывает на создаваемый экземпляр.\n5) В стрелочных функциях — `this` берётся из внешнего лексического окружения."
  },
  {
    "id": "js-042",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в стрелочной функции?",
    "answer": "Стрелочная функция не имеет собственного `this`.\n\nОна захватывает `this` из внешнего лексического окружения в момент создания.\n\nЕё `this` нельзя изменить через `call`, `apply`, `bind` и нельзя использовать с `new`."
  },
  {
    "id": "js-043",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между call, apply и bind?",
    "answer": "Все три метода позволяют явно установить `this`.\n\n- `call` — вызывает функцию сразу, аргументы передаются списком.\n- `apply` — вызывает функцию сразу, аргументы передаются массивом.\n- `bind` — возвращает новую функцию с привязанным `this`, но не вызывает её сразу."
  },
  {
    "id": "js-044",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что будет если вызвать метод без объекта?",
    "answer": "Если сохранить метод в переменную и вызвать отдельно, связь с объектом теряется.\n\nВ strict mode `this` будет `undefined`, в обычном режиме — глобальный объект.\n\nПотому что при вызове нет объекта слева от точки."
  },
  {
    "id": "js-045",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое потеря контекста?",
    "answer": "Потеря контекста — это ситуация, когда метод объекта вызывается отдельно и `this` перестаёт указывать на исходный объект.\n\nЧаще всего происходит при передаче метода как callback."
  },
  {
    "id": "js-046",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как исправить потерю контекста?",
    "answer": "Основные способы:\n\n1) Использовать `bind`.\n2) Обернуть вызов в стрелочную функцию.\n3) В классе — привязать метод в конструкторе.\n\nСамый универсальный способ — `bind`."
  },
  {
    "id": "js-047",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что будет если использовать new с bind?",
    "answer": "Если функция была привязана через `bind`, а затем вызвана с `new`, приоритет получает `new`.\n\nСоздаётся новый объект, и `this` указывает на него, игнорируя привязанный контекст."
  },
  {
    "id": "js-048",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в class?",
    "answer": "В class `this` работает как в функции-конструкторе.\n\nПри вызове через `new` он указывает на созданный экземпляр.\n\nМетоды класса не привязываются автоматически, поэтому возможна потеря контекста при передаче метода как callback."
  },
  {
    "id": "js-049",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в strict mode?",
    "answer": "В strict mode при обычном вызове функции `this` равен `undefined`.\n\nВ нестрогом режиме `this` в таком случае указывает на глобальный объект.\n\nStrict mode предотвращает неявную привязку к глобальному объекту."
  },
  {
    "id": "js-050",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему стрелочные функции нельзя использовать как конструктор?",
    "answer": "Стрелочные функции не имеют собственного `this` и `prototype`.\n\nУ них отсутствует внутренний метод `[[Construct]]`, поэтому вызов через `new` приведёт к ошибке.\n\nОни предназначены для сохранения лексического `this`, а не для создания экземпляров."
  },

  {
    "id": "js-051",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Event Loop?",
    "answer": "Event Loop — это механизм, который управляет выполнением асинхронного кода в JavaScript.\n\nJavaScript однопоточный, поэтому сначала выполняется весь синхронный код (call stack). Когда стек пуст, Event Loop берёт задачи из очередей и помещает их в стек.\n\nОн обеспечивает неблокирующее выполнение через очереди macrotask и microtask."
  },
  {
    "id": "js-052",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между microtask и macrotask?",
    "answer": "Macrotask — это задачи вроде `setTimeout`, `setInterval`, `setImmediate`.\n\nMicrotask — это задачи из `Promise.then`, `catch`, `finally`, `queueMicrotask`.\n\nПосле выполнения текущего синхронного кода сначала полностью очищается очередь microtask, и только потом выполняется следующая macrotask."
  },
  {
    "id": "js-053",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где выполняется Promise?",
    "answer": "Колбэки `then`, `catch`, `finally` выполняются в очереди microtask.\n\nСам executor внутри `new Promise()` выполняется синхронно, а обработчики результата — асинхронно через microtask."
  },
  {
    "id": "js-054",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему Promise выполняется раньше setTimeout?",
    "answer": "Потому что обработчики Promise попадают в очередь microtask.\n\nEvent Loop сначала очищает всю очередь microtask, и только потом берёт следующую macrotask (например `setTimeout`).\n\nПоэтому `Promise.then` всегда выполнится раньше `setTimeout(..., 0)`."
  },
  {
    "id": "js-055",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое callback hell?",
    "answer": "Callback hell — это ситуация, когда асинхронные операции вложены друг в друга через колбэки, образуя «лестницу».\n\nКод становится трудно читаемым, сложным для поддержки и обработки ошибок.\n\nPromise и async/await были созданы как решение этой проблемы."
  },
  {
    "id": "js-056",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Promise?",
    "answer": "Promise — это объект, представляющий результат асинхронной операции.\n\nОн может находиться в трёх состояниях:\n- pending (ожидание)\n- fulfilled (выполнен успешно)\n- rejected (ошибка)\n\nPromise позволяет обрабатывать результат через `then`, `catch`, `finally`."
  },
  {
    "id": "js-057",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Promise chaining?",
    "answer": "Promise chaining — это последовательное выполнение асинхронных операций через возврат значения или нового Promise внутри `then`.\n\nКаждый `then` возвращает новый Promise, что позволяет строить цепочки без вложенности.\n\nЭто делает код линейным и читаемым."
  },
  {
    "id": "js-058",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что произойдёт если не вернуть promise в then?",
    "answer": "Если внутри `then` не вернуть Promise или значение, следующий `then` получит `undefined`.\n\nЕсли запустить асинхронную операцию внутри `then`, но не вернуть её, цепочка не будет ждать её завершения.\n\nЭто частая ошибка, из-за которой нарушается порядок выполнения."
  },
  {
    "id": "js-059",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое async/await?",
    "answer": "`async/await` — это синтаксический сахар над Promise.\n\nФункция с `async` всегда возвращает Promise.\n\n`await` приостанавливает выполнение функции до тех пор, пока Promise не завершится, и возвращает его результат.\n\nЭто делает асинхронный код похожим на синхронный."
  },
  {
    "id": "js-060",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как обрабатывать ошибки в async/await?",
    "answer": "Ошибки обрабатываются через `try/catch` внутри async-функции.\n\nЕсли Promise внутри `await` будет отклонён (rejected), управление перейдёт в блок `catch`.\n\nТакже можно обрабатывать ошибки на уровне вызова через `.catch()`."
  },
   {
    "id": "js-061",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что выполняется раньше: setTimeout или Promise?",
    "answer": "Promise выполнится раньше.\n\nОбработчики `Promise.then` попадают в очередь **microtask**, а `setTimeout` — в очередь **macrotask**.\n\nПосле выполнения текущего синхронного кода Event Loop сначала полностью очищает очередь microtask, и только потом берёт следующую macrotask.\n\nПоэтому `Promise.then` всегда выполняется раньше `setTimeout(..., 0)`."
  },
  {
    "id": "js-062",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где выполняется requestAnimationFrame?",
    "answer": "`requestAnimationFrame` выполняется перед следующим перерисовыванием кадра браузером.\n\nОн попадает в специальную очередь, которая обрабатывается перед repaint.\n\nИспользуется для анимаций, потому что синхронизируется с частотой обновления экрана."
  },
  {
    "id": "js-063",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает queueMicrotask?",
    "answer": "`queueMicrotask` добавляет функцию в очередь microtask.\n\nОна выполнится после текущего синхронного кода, но раньше любой macrotask.\n\nЭто низкоуровневый способ добавить задачу в ту же очередь, что и `Promise.then`."
  },
  {
    "id": "js-064",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Когда очищается call stack?",
    "answer": "Call stack очищается, когда завершается выполнение текущей функции.\n\nКогда стек становится пустым, Event Loop может взять следующую задачу из очереди.\n\nЕсли стек никогда не освобождается (например бесконечный цикл), асинхронные задачи не выполняются."
  },
  {
    "id": "js-065",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Можно ли заблокировать event loop?",
    "answer": "Да. Если выполнить долгий синхронный код (например тяжёлый цикл или рекурсию), call stack будет занят.\n\nПока стек не освободится, Event Loop не сможет обрабатывать очереди задач.\n\nЭто приводит к «зависанию» интерфейса."
  },
  {
    "id": "js-066",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое starvation?",
    "answer": "Starvation — это ситуация, когда одни задачи не получают выполнение из-за постоянного добавления других задач с более высоким приоритетом.\n\nНапример, если бесконечно добавлять microtask, macrotask могут долго не выполняться.\n\nЭто проблема баланса очередей в Event Loop."
  },
  {
    "id": "js-067",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Чем отличается setImmediate?",
    "answer": "`setImmediate` — это API, доступный в Node.js (и некоторых средах), которое ставит задачу в очередь, выполняемую после текущей фазы I/O.\n\nВ браузерах его обычно нет.\n\nПо смыслу он ближе к macrotask, но порядок выполнения отличается от `setTimeout` в зависимости от среды."
  },
  {
    "id": "js-068",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает fetch?",
    "answer": "`fetch` отправляет HTTP-запрос и возвращает Promise.\n\nСам запрос выполняется в среде браузера (Web APIs), а не в call stack.\n\nКогда ответ получен, результат помещается в очередь microtask через Promise.\n\n`fetch` всегда возвращает Promise, даже при ошибках HTTP."
  },
  {
    "id": "js-069",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему fetch не кидает ошибку при 404?",
    "answer": "`fetch` считает ошибкой только сетевые сбои (например отсутствие соединения).\n\nHTTP-статусы вроде 404 или 500 — это корректный ответ сервера, поэтому Promise считается успешно выполненным.\n\nЧтобы проверить ошибку, нужно анализировать `response.ok` или `response.status`."
  },
  {
    "id": "js-070",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое AbortController?",
    "answer": "`AbortController` — это объект, который позволяет отменять асинхронные операции, например `fetch`.\n\nСоздаётся контроллер, его `signal` передаётся в запрос, и при вызове `abort()` операция прерывается.\n\nИспользуется для отмены запросов при размонтировании компонентов или смене страницы."
  },
    {
    "id": "js-071",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между map и forEach?",
    "answer": "`map` создаёт и возвращает новый массив, применяя функцию к каждому элементу.\n\n`forEach` просто выполняет функцию для каждого элемента и ничего не возвращает (undefined).\n\n`map` используется для преобразования данных, а `forEach` — когда нужно выполнить побочное действие."
  },
  {
    "id": "js-072",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "filter возвращает новый массив?",
    "answer": "Да. `filter` всегда возвращает новый массив.\n\nОн проходит по массиву и добавляет в новый массив только те элементы, для которых функция возвращает true.\n\nОригинальный массив при этом не изменяется."
  },
  {
    "id": "js-073",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое reduce?",
    "answer": "`reduce` — это метод, который сворачивает массив к одному значению.\n\nОн принимает функцию-аккумулятор и начальное значение.\n\nНа каждой итерации возвращённое значение становится новым аккумулятором.\n\nИспользуется для суммирования, группировки, преобразования в объект и других операций."
  },
  {
    "id": "js-074",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает sort?",
    "answer": "`sort` сортирует массив на месте (мутирует его).\n\nПо умолчанию элементы преобразуются в строки и сравниваются по Unicode.\n\nМожно передать функцию сравнения `(a, b) => a - b`, чтобы задать числовую или пользовательскую сортировку."
  },
  {
    "id": "js-075",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему sort работает странно с числами?",
    "answer": "По умолчанию `sort` сравнивает элементы как строки.\n\nНапример, `[1, 2, 10]` станет `[1, 10, 2]`, потому что строки сравниваются посимвольно.\n\nЧтобы корректно сортировать числа, нужно передать функцию сравнения: `(a, b) => a - b`."
  },
  {
    "id": "js-076",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как удалить дубликаты из массива?",
    "answer": "Самый простой способ — использовать `Set`, который хранит только уникальные значения.\n\nПример концепции: создать Set из массива и затем преобразовать его обратно в массив.\n\nТакже можно использовать `filter` или `reduce`, но Set — самый лаконичный способ."
  },
  {
    "id": "js-077",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между slice и splice?",
    "answer": "`slice` возвращает новый массив и не изменяет оригинальный.\n\n`splice` изменяет исходный массив: может удалять, добавлять или заменять элементы.\n\n`slice` — безопасная операция, `splice` — мутирующая."
  },
  {
    "id": "js-078",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает flat?",
    "answer": "`flat` создаёт новый массив, «разворачивая» вложенные массивы на указанную глубину.\n\nПо умолчанию глубина равна 1.\n\nМетод не мутирует исходный массив."
  },
  {
    "id": "js-079",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое immutable операции?",
    "answer": "Immutable операции — это операции, которые не изменяют исходные данные, а возвращают новые.\n\nПримеры: `map`, `filter`, `slice`, spread.\n\nОни важны в функциональном программировании и в React, где состояние должно обновляться без мутаций."
  },
  {
    "id": "js-080",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает find?",
    "answer": "`find` возвращает первый элемент массива, который удовлетворяет условию.\n\nЕсли элемент не найден, возвращается undefined.\n\nВ отличие от `filter`, `find` останавливается после первого совпадения."
  },

    {
    "id": "js-081",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое destructuring?",
    "answer": "Destructuring — это синтаксис, позволяющий извлекать значения из массивов или объектов и присваивать их переменным.\n\nДля массивов — по позиции.\nДля объектов — по имени свойства.\n\nПозволяет писать более краткий и читаемый код, особенно при работе с параметрами функций."
  },
  {
    "id": "js-082",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое default parameters?",
    "answer": "Default parameters — это значения по умолчанию для параметров функции.\n\nЕсли аргумент не передан или равен `undefined`, используется значение по умолчанию.\n\nЭто избавляет от необходимости вручную проверять аргументы внутри функции."
  },
  {
    "id": "js-083",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое optional chaining?",
    "answer": "Optional chaining (`?.`) позволяет безопасно обращаться к вложенным свойствам объекта.\n\nЕсли промежуточное значение равно `null` или `undefined`, выражение возвращает `undefined` вместо ошибки.\n\nУдобно при работе с вложенными структурами данных."
  },
  {
    "id": "js-084",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое nullish coalescing?",
    "answer": "Nullish coalescing (`??`) возвращает правое значение, если левое равно `null` или `undefined`.\n\nВ отличие от `||`, он не считает falsy-значения вроде 0 или пустую строку поводом для замены.\n\nИспользуется для безопасного задания значений по умолчанию."
  },
  {
    "id": "js-085",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Symbol?",
    "answer": "Symbol — это примитивный тип данных, создающий уникальное значение.\n\nДаже если создать два Symbol с одинаковым описанием, они будут разными.\n\nЧасто используется для создания уникальных ключей объектов, чтобы избежать конфликтов."
  },
  {
    "id": "js-086",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое iterator?",
    "answer": "Iterator — это объект, который реализует метод `next()`.\n\nМетод `next()` возвращает объект вида `{ value, done }`.\n\nИтераторы позволяют поэлементно обходить коллекции. Они лежат в основе цикла `for...of`."
  },
  {
    "id": "js-087",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое generator?",
    "answer": "Generator — это специальная функция, которая может приостанавливать выполнение с помощью `yield`.\n\nОна возвращает итератор.\n\nПри каждом вызове `next()` выполнение продолжается до следующего `yield`.\n\nПозволяет управлять последовательностью выполнения."
  },
  {
    "id": "js-088",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между for...in и for...of?",
    "answer": "`for...in` перебирает ключи (имена свойств) объекта.\n\n`for...of` перебирает значения и работает только с итерируемыми объектами (массивы, строки, Set, Map).\n\nДля массивов обычно используют `for...of`, а не `for...in`."
  },
  {
    "id": "js-089",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Set?",
    "answer": "Set — это коллекция уникальных значений.\n\nОн автоматически удаляет дубликаты и поддерживает методы `add`, `delete`, `has`.\n\nПолезен для работы с уникальными элементами."
  },
  {
    "id": "js-090",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Map?",
    "answer": "Map — это коллекция пар ключ-значение.\n\nВ отличие от обычного объекта, ключами могут быть любые значения (включая объекты).\n\nMap сохраняет порядок добавления элементов и имеет методы `set`, `get`, `has`, `delete`."
  },
  {
    "id": "js-091",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между CommonJS и ES Modules?",
    "answer": "CommonJS используется в Node.js (require / module.exports), а ES Modules — современный стандарт (import / export).\n\nОсновные различия:\n\n- CommonJS загружает модули синхронно.\n- ES Modules работают статически: import анализируется до выполнения кода.\n- ES Modules поддерживают tree shaking.\n- В ES Modules `this` в верхнем уровне равен undefined.\n\nСегодня ES Modules — стандарт в браузере и современном Node."
  },
  {
    "id": "js-092",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое tree shaking?",
    "answer": "Tree shaking — это удаление неиспользуемого кода при сборке проекта.\n\nРаботает благодаря статической структуре ES Modules: сборщик может определить, какие экспорты не используются, и убрать их из итогового бандла.\n\nЭто уменьшает размер финального файла."
  },
  {
    "id": "js-093",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Можно ли импортировать динамически?",
    "answer": "Да. В ES Modules существует динамический импорт через `import()`.\n\nОн возвращает Promise и позволяет загружать модуль во время выполнения.\n\nИспользуется для ленивой загрузки (code splitting)."
  },
  {
    "id": "js-094",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Когда выполняется код модуля?",
    "answer": "Код ES-модуля выполняется один раз при первом импорте.\n\nПосле этого модуль кэшируется, и повторные импорты используют уже выполненную версию.\n\nImport обрабатывается до выполнения остального кода файла."
  },
  {
    "id": "js-095",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое top-level await?",
    "answer": "Top-level await позволяет использовать `await` прямо в модуле, вне async-функции.\n\nПри этом выполнение модуля приостанавливается до завершения Promise.\n\nИспользуется для инициализации данных до загрузки приложения."
  },
  {
    "id": "js-096",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает garbage collector?",
    "answer": "Современные движки используют алгоритм mark-and-sweep.\n\n1) От корневых объектов (global, стек) помечаются достижимые объекты.\n2) Недостижимые объекты удаляются.\n\nОбъект удаляется, если на него больше нет ссылок.\n\nЗамыкания могут удерживать ссылки и препятствовать освобождению памяти."
  },
  {
    "id": "js-087",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое WeakMap?",
    "answer": "WeakMap — это коллекция ключ-значение, где ключами могут быть только объекты.\n\nГлавная особенность — ключи хранятся \"слабо\". Если на объект больше нет других ссылок, он может быть удалён сборщиком мусора.\n\nИспользуется для хранения приватных данных, связанных с объектами."
  },
  {
    "id": "js-098",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему WeakMap не итерируется?",
    "answer": "WeakMap не поддерживает перебор (нет методов keys, values, entries), потому что его ключи могут быть удалены сборщиком мусора в любой момент.\n\nЕсли бы перебор был возможен, поведение коллекции стало бы непредсказуемым."
  },
  {
    "id": "js-099",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Proxy?",
    "answer": "Proxy — это объект-обёртка, который позволяет перехватывать операции над другим объектом.\n\nМожно перехватывать чтение, запись, удаление свойств, вызовы функций и другие действия.\n\nИспользуется для валидации, реактивности, логирования и создания фреймворков."
  },
  {
    "id": "js-100",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Reflect?",
    "answer": "Reflect — это встроенный объект с методами для работы с объектами (get, set, defineProperty и др.).\n\nОн дублирует низкоуровневые операции JavaScript, но в виде функций.\n\nЧасто используется вместе с Proxy, чтобы корректно передавать операции оригинальному объекту."
  },
  {
    "id": "dom-003",
    "topicId": "dom",
    "topicTitle": "DOM / Events",
    "question": "innerHTML vs innerText vs textContent: разница и безопасность?",
    "answer": "innerHTML — вставка HTML, риск XSS.\ninnerText — видимый текст, может быть медленнее (учёт CSS).\ntextContent — весь текст, быстрее, безопаснее для вставки текста.\nПравило: нужен текст → textContent; нужен HTML → innerHTML осознанно.",
    "tags": ["dom", "xss"]
  },
  {
    "id": "dom-004",
    "topicId": "dom",
    "topicTitle": "DOM / Events",
    "question": "Позиционирование: static/relative/absolute/fixed/sticky — в чём смысл?",
    "answer": "static — обычный поток.\nrelative — в потоке, можно смещать; якорь для absolute.\nabsolute — вне потока, относительно ближайшего position != static (или документа).\nfixed — относительно окна.\nsticky — как relative, но «прилипает» после порога.",
    "tags": ["css", "position"]
  },
  {
    "id": "events-001",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "Event bubbling: что это и зачем нужно?",
    "answer": "Событие всплывает от целевого элемента к родителям. Даёт делегирование событий и уменьшает количество обработчиков.",
    "tags": ["events", "bubbling"]
  },
  {
    "id": "events-002",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "Event capturing: что это и фазы событий?",
    "answer": "Capturing идёт сверху вниз до target, затем target phase, затем bubbling снизу вверх. Capturing используют реже, но важно знать модель фаз.",
    "tags": ["events", "capturing"]
  },
  {
    "id": "events-003",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "stopPropagation vs stopImmediatePropagation — разница?",
    "answer": "stopPropagation останавливает дальнейшее распространение по DOM, но другие обработчики на этом же элементе продолжат.\nstopImmediatePropagation останавливает и распространение, и остальные обработчики на этом элементе.",
    "tags": ["events"]
  },
  {
    "id": "events-004",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "preventDefault: что отменяет и чем отличается от stopPropagation?",
    "answer": "preventDefault отменяет стандартное действие браузера (переход по ссылке, submit формы и т.д.).\nstopPropagation — про распространение события по DOM.",
    "tags": ["events"]
  },
  {
    "id": "events-005",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "this в event handler: обычная функция vs стрелка?",
    "answer": "Обычная функция: this часто указывает на элемент, на котором висит handler.\nСтрелка: this берётся из внешнего контекста, обычно не DOM-элемент → частая путаница.",
    "tags": ["events", "this"]
  },
  {
    "id": "events-006",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "Event delegation: что это и почему важно?",
    "answer": "Один обработчик на родителе вместо множества на детях. Основано на bubbling. Плюсы: меньше памяти, работает с динамическими элементами, проще логика списков/таблиц.",
    "tags": ["events", "delegation"]
  },

  {
    "id": "perf-001",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "async vs defer: в чём разница и что чаще используют для основного JS?",
    "answer": "async: загрузка параллельно, выполняется сразу после загрузки, порядок не гарантирован.\ndefer: загрузка параллельно, выполняется после парсинга HTML, порядок сохраняется.\nОбычно основной JS — defer.",
    "tags": ["html", "scripts"]
  },
  {
    "id": "perf-002",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "LocalStorage vs SessionStorage — отличия и ограничения?",
    "answer": "LocalStorage живёт долго и доступен во всех вкладках одного origin.\nSessionStorage живёт в рамках вкладки и очищается при закрытии.\nОба: синхронные, хранят строки, не для чувствительных данных.",
    "tags": ["storage"]
  },
  {
    "id": "perf-003",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "Ограничения browser storage и риски безопасности?",
    "answer": "Обычно 5–10MB на origin. Доступ только в рамках origin. Данные легко смотреть в DevTools. storage доступен из JS → при XSS можно украсть.",
    "tags": ["storage", "security"]
  },
  {
    "id": "perf-004",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "Cookie vs Storage: ключевой вывод выбора для auth и состояния?",
    "answer": "Cookie — часть HTTP и уходят с каждым запросом; есть HttpOnly/Secure/SameSite → подходят для auth.\nStorage — не отправляется автоматически, проще, но уязвим к XSS.\nВывод: auth → cookie, клиентское состояние → storage.",
    "tags": ["cookies", "storage", "auth"]
  },
  {
    "id": "perf-005",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "Почему важно чистить listeners и intervals в SPA?",
    "answer": "Если не снять listener/не очистить interval — остаются ссылки → GC не освобождает память, логика работает «в никуда», возможны утечки и лишняя нагрузка.",
    "tags": ["memory-leak", "spa"]
  },
  {
    "id": "perf-006",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "ResizeObserver: что решает и почему тоже нужно отключать?",
    "answer": "Следит за изменениями размеров конкретного элемента (не только окна). Полезен для адаптивных компонентов и динамических layout. Observer нужно отключать, иначе лишние вычисления/утечки.",
    "tags": ["browser", "observer"]
  },
  {
    "id": "perf-007",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "IntersectionObserver: зачем и где применяют?",
    "answer": "Отслеживает появление/исчезновение элемента в viewport/контейнере. Кейс: lazy loading, бесконечный скролл, аналитика видимости. Нужно отключать при ненадобности.",
    "tags": ["browser", "observer"]
  },
  {
    "id": "perf-008",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "Web Vitals: LCP/CLS/INP — что измеряют и от чего страдают?",
    "answer": "LCP — скорость появления крупнейшего элемента (картинки, блокирующий JS, медленный сервер).\nCLS — «прыжки» layout (картинки без размеров, динамический контент, шрифты).\nINP — отзывчивость на действия (long tasks, тяжёлые handlers, перегруз main thread).",
    "tags": ["performance", "web-vitals"]
  },

  {
    "id": "css-001",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "CSS Box Model: из чего состоит и типичная ошибка с width/height?",
    "answer": "content + padding + border + margin. Типичная ошибка: задать width и добавить padding/border → элемент станет больше ожидаемого.",
    "tags": ["css", "box-model"]
  },
  {
    "id": "css-002",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "box-sizing: border-box — что меняет и почему его ставят глобально?",
    "answer": "border-box включает padding и border в width/height → размеры предсказуемы, меньше багов верстки. Поэтому часто задают глобально.",
    "tags": ["css", "box-sizing"]
  },
  {
    "id": "css-003",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Центрирование: почему нет одного универсального способа?",
    "answer": "Нужно понять контекст: по горизонтали/вертикали, один элемент/группа, внутри блока/страницы. Часто решают flex/grid/margin auto.",
    "tags": ["css", "layout"]
  },
  {
    "id": "css-004",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Flexbox: ключевая идея и ограничение?",
    "answer": "Модель распределения по одной оси (главная/поперечная). Отлично для выравнивания и адаптивных рядов/колонок. Для двухмерных сеток лучше Grid.",
    "tags": ["css", "flexbox"]
  },
  {
    "id": "css-005",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "CSS Grid: чем отличается от flexbox и когда лучше?",
    "answer": "Grid — двухмерная сетка (строки и колонки одновременно) и управление структурой layout. Flexbox — одна ось и выравнивание. Часто используются вместе.",
    "tags": ["css", "grid"]
  },
  {
    "id": "css-006",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Responsive layout: идея и инструменты?",
    "answer": "Адаптация под разные экраны без отдельной «мобильной версии»: гибкие размеры, media queries, flex/grid, относительные единицы. Важно: не только ширина, но устройства/ориентации/плотность пикселей.",
    "tags": ["css", "responsive"]
  },
  {
    "id": "css-007",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "px vs em vs rem — когда что использовать?",
    "answer": "px — абсолютная, предсказуемая, но хуже масштабируется.\nem — от font-size родителя (может «накапливаться»).\nrem — от корневого font-size, удобно масштабировать весь интерфейс.\nПрактика: rem для UI, em локально, px точечно.",
    "tags": ["css", "units"]
  },
  {
    "id": "css-008",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Семантическая вёрстка: зачем и примеры тегов?",
    "answer": "HTML про структуру и смысл, CSS про внешний вид. Семантика улучшает доступность, SEO и поддержку. Примеры: header/footer/main/section/article/nav/aside.",
    "tags": ["html", "semantic"]
  },
  {
    "id": "css-009",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "CSS prefixes: что это и почему сейчас редко пишут руками?",
    "answer": "Вендорные префиксы для экспериментальных свойств (-webkit-, -moz-...). Сейчас редко вручную: стабильнее стандарты, а префиксы обычно добавляет сборка.",
    "tags": ["css", "prefixes"]
  },
  {
    "id": "css-010",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Autoprefixer: что делает и от чего зависит?",
    "answer": "Автоматически добавляет нужные CSS-префиксы на этапе сборки, ориентируясь на целевые браузеры (настройки поддержки).",
    "tags": ["css", "tooling"]
  },

  {
    "id": "tool-001",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "Bundlers (webpack/vite): зачем нужны и разница подхода dev/prod?",
    "answer": "Бандлер собирает модули в бандлы для браузера, трансформирует код, оптимизирует размер и ассеты.\nwebpack: классическая сборка заранее.\nvite: dev через native ESM, prod — сборка.",
    "tags": ["tooling", "bundler"]
  },
  {
    "id": "tool-002",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "Dev vs Prod сборка: ключевые различия?",
    "answer": "Dev: скорость разработки, неминифицировано, sourcemaps, быстрые пересборки.\nProd: производительность, минификация, tree-shaking, оптимизация ассетов, отключение dev-инструментов.",
    "tags": ["tooling", "build"]
  },
  {
    "id": "tool-003",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "Source maps: зачем и нюансы в продакшене?",
    "answer": "Показывают соответствие исходного и собранного кода для отладки и stack trace. В проде могут отключать/хранить отдельно — баланс удобства и безопасности/размера.",
    "tags": ["tooling", "sourcemaps"]
  },
  {
    "id": "tool-004",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "npm install vs npm ci — когда что?",
    "answer": "npm install читает package.json и может менять lock — удобно локально.\nnpm ci ставит строго по package-lock, не меняет его и чистит node_modules — идеально для CI и повторяемых сборок.",
    "tags": ["npm", "ci"]
  },
  {
    "id": "tool-005",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "package-lock.json: зачем нужен и что фиксирует?",
    "answer": "Фиксирует точные версии всей зависимости цепочки. package.json — что разрешено, lock — что фактически установлено. Нужен для одинаковых версий у всех и воспроизводимых сборок.",
    "tags": ["npm", "lockfile"]
  },
  {
    "id": "git-001",
    "topicId": "git",
    "topicTitle": "Git",
    "question": "git fetch vs git pull — разница?",
    "answer": "fetch скачивает изменения и обновляет ссылки origin/*, но не меняет текущую ветку.\npull = fetch + merge/rebase и сразу применяет изменения к текущей ветке.",
    "tags": ["git"]
  },
  {
    "id": "git-002",
    "topicId": "git",
    "topicTitle": "Git",
    "question": "git merge vs git rebase — концептуальная разница и правило?",
    "answer": "merge создаёт merge-коммит и сохраняет историю ветвления (безопаснее для команды).\nrebase переписывает историю и делает её линейной (опасно на общих ветках).\nПравило: rebase локально, merge для общих веток.",
    "tags": ["git"]
  },
  {
    "id": "git-003",
    "topicId": "git",
    "topicTitle": "Git",
    "question": "Staging area (index): зачем нужен?",
    "answer": "Промежуточный слой: ты явно выбираешь, какие изменения попадут в коммит. Коммит берёт только то, что в staging. Это основа аккуратных коммитов и работы в команде.",
    "tags": ["git", "staging"]
  },
  {
    "id": "git-004",
    "topicId": "git",
    "topicTitle": "Git",
    "question": "Конфликты из-за EOL (LF vs CRLF): почему бывают и как решают (на уровне идеи)?",
    "answer": "Разные ОС/настройки дают разные концы строк → git видит «изменения» и конфликты. Решают единым форматом в проекте и настройками git/editor на нормализацию.",
    "tags": ["git", "eol"]
  },
  {
    "id": "ci-001",
    "topicId": "ci",
    "topicTitle": "CI/CD",
    "question": "CI/CD: что такое и разница Delivery vs Deployment?",
    "answer": "CI — автоматические сборки/тесты/линтеры при изменениях.\nCD — доставка/деплой. Delivery: код готов к выкладке (ручной шаг). Deployment: выкладывается автоматически.",
    "tags": ["ci", "cd"]
  }
]
