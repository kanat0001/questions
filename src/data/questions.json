[

  {
    "id": "js-001",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между var, let и const?",
    "answer": "В JavaScript переменные можно объявлять через `var`, `let` и `const`, но они отличаются областью видимости, hoisting и правилами повторного объявления.\n\n- **`var`** — имеет **функциональную область видимости** (не блочную). При hoisting объявление поднимается вверх и **сразу инициализируется `undefined`**, поэтому к переменной можно обратиться до строки объявления, но получишь `undefined`. Разрешает **переобъявление в той же области**, из-за чего легко словить баги.\n\n- **`let`** — имеет **блочную область видимости**. Тоже поднимается (hoisting есть), но до инициализации находится в **TDZ**, поэтому обращение до строки объявления даст **ReferenceError**. **Повторно объявить нельзя**, но **переназначать значение можно**.\n\n- **`const`** — как `let` по scope и TDZ, но **нельзя переназначить ссылку**. При этом **объекты/массивы можно мутировать**, потому что меняется содержимое, а не ссылка."
  },
  {
    "id": "js-002",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Temporal Dead Zone?",
    "answer": "Temporal Dead Zone (TDZ) — это промежуток времени в пределах блока, когда переменная `let/const` уже **создана** (движок знает о ней), но ещё **не инициализирована**.\n\nПроще: с начала блока `{ ... }` и до строки, где выполнится `let a = ...`, переменная `a` находится в TDZ. Если попытаться обратиться к ней в этот момент, будет **ReferenceError**.\n\nTDZ существует, чтобы предотвратить использование переменной «до объявления» и сделать код предсказуемее (в отличие от `var`, который даёт `undefined`)."
  },
  {
    "id": "js-003",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое hoisting и что именно хойстится?",
    "answer": "Hoisting — это механизм JavaScript, при котором объявления переменных и функций поднимаются в начало области видимости до выполнения кода. Это нужно для того, чтобы движок заранее знал о существовании переменных и функций и мог корректно построить область видимости перед выполнением кода."
  },
  {
    "id": "js-004",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между function declaration и function expression?",
    "answer": "Function Declaration — это способ объявления функции через ключевое слово function, при котором функция полностью поднимается в начало области видимости и может быть вызвана до её объявления. Function Expression — это функция, присвоенная переменной. Она не поднимается как функция и доступна только после объявления переменной."
  },
  {
    "id": "js-005",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему функции — объекты?",
    "answer": "«В JavaScript функции — это вызываемые объекты (Callable Objects). Они являются объектами первого класса, так как наследуются от глобального конструктора Object через цепочку прототипов (Function.prototype -> Object.prototype). Технически это обычные объекты, у которых есть дополнительный скрытый метод [[Call]], позволяющий выполнять код внутри функции при обращении через круглые скобки».Почему это важно (суть): Если бы функции не были объектами, мы не могли бы: Передавать их в другие функции как переменные (Callback). Вешать на них методы (как в jQuery или библиотеках валидации). Создавать из них конструкторы через new."
  },
  {
    "id": "js-006",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое область видимости (scope)?",
    "answer": "область видимости — это просто «зона действия» переменной. Это правила, которые определяют, где в коде мы можем использовать конкретную переменную, а где она «не существует». Иерархия (Матрешка): Поиск переменной всегда идет снизу вверх. Если функции нужна переменная, она сначала ищет её у себя внутри. Не нашла? Идет искать в ту функцию, внутри которой она написана. И так до самого верха — до глобальной области. Лексичность: Это самое важное. Область видимости фиксируется в момент, когда ты пишешь код, а не когда ты его запускаешь. Функция навсегда запоминает то место, где она была создана, и «видит» переменные, которые были вокруг неё в тот момент."
  },
  {
    "id": "js-007",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое lexical environment?",
    "answer": "Lexical Environment — это внутреннее окружение выполнения, которое хранит текущие переменные и ссылку на внешнее окружение. Благодаря этому JavaScript реализует лексическую область видимости. Если чуть глубже: Каждый вызов функции создаёт новый lexical environment, содержащий свои переменные и ссылку на родительское окружение, что позволяет реализовать цепочку областей видимости (scope chain)."
  },
  {
    "id": "js-008",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что хранится в call stack?",
    "answer": "Call Stack — это структура данных, которая хранит контексты выполнения вызываемых функций. Каждый вызов функции помещается в стек и удаляется после завершения. Если чуть глубже: В Call Stack хранятся execution context'ы функций: их переменные, параметры и информация о текущем месте выполнения кода."
  },
  {
    "id": "js-009",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает цепочка областей видимости (scope chain)?",
    "answer": "Scope chain — это механизм поиска переменных, при котором JavaScript сначала ищет переменную в текущей области видимости, затем во внешней и так далее до глобальной области. Если чуть глубже: Scope chain формируется через lexical environment: каждый execution context содержит ссылку на внешнее окружение, благодаря чему создаётся цепочка областей видимости."
  },
  {
    "id": "js-010",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему typeof null === object ?",
    "answer": "Это историческая особенность JavaScript (по сути баг), которая тянется с самых ранних версий языка. В первых реализациях значения имели внутренние «теги» типов, и у `null` оказался тег, который совпал с `object`. Поэтому оператор `typeof` возвращает Исправить это нельзя без поломки огромного количества старого кода, поэтому поведение закрепили ради обратной совместимости."
  },
  {
    "id": "js-011",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Какие есть примитивные типы в JavaScript?",
    "answer": "В JavaScript существует 7 примитивных типов: string, number, boolean, null, undefined, symbol и bigint. Примитивы хранятся по значению и являются неизменяемыми. Все остальные типы в JavaScript являются объектами."
  },
  {
    "id": "js-012",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое boxing?",
    "answer": "Boxing — это автоматическое временное преобразование примитивного значения в объект-обёртку, чтобы можно было использовать методы и свойства. Если чуть глубже: При обращении к методу примитива JavaScript создаёт соответствующий объект-обёртку (например, String), выполняет операцию и затем удаляет его."
  },
  {
    "id": "js-013",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между == и ===?",
    "answer": "== выполняет сравнение с приведением типов, а === сравнивает значения без приведения типов и требует совпадения типа и значения."
  },
  {
    "id": "js-014",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое неявное приведение типов?",
    "answer": "Неявное приведение типов — это автоматическое преобразование одного типа данных в другой, которое JavaScript выполняет во время операций или сравнений. Оно происходит при арифметических операциях, сравнении через ==, логических операциях и других выражениях."
  },
  {
    "id": "js-015",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что вернет [] + {} и почему?",
    "answer": "[] + {} вернёт строку [object Object], потому что оператор + приводит операнды к примитивам. Массив превращается в пустую строку через toString(), объект — в [object Object], после чего происходит строковая конкатенация."
  },
  {
    "id": "js-016",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что вернет {} + []?",
    "answer": "{} + [] в начале строки интерпретируется как пустой блок и унарный плюс, поэтому результат — 0. Если же выражение обернуть в скобки, оно вернёт строку [object Object] из-за приведения объектов к примитивам."
  },
  {
    "id": "js-017",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему NaN !== NaN?",
    "answer": "NaN !== NaN, потому что по стандарту IEEE 754 значение NaN не равно ничему, даже самому себе. Поэтому для проверки используется Number.isNaN()."
  },
  {
    "id": "js-018",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как правильно проверить значение на NaN?",
    "answer": "Проверять значение на NaN нужно через Number.isNaN(), потому что обычное сравнение не работает, а глобальный isNaN() выполняет неявное приведение типов."
  },
  {
    "id": "js-019",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между null и undefined?",
    "answer": "undefined означает, что значение не было присвоено, а null — это намеренно установленное пустое значение. Они равны при нестрогом сравнении, но имеют разные типы. undefined обычно устанавливается движком автоматически, а null присваивается разработчиком явно."
  },
  {
    "id": "js-020",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое falsy значения?",
    "answer": "Falsy значения — это значения, которые при приведении к Boolean дают false. В JavaScript их восемь: false, 0, -0, 0n, пустая строка, null, undefined и NaN. Falsy значения участвуют в неявном приведении типов в логических операциях и условиях."
  },

   {
    "id": "js-021",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое prototype?",
    "answer": "Prototype — это механизм наследования в JavaScript, при котором объект может получать доступ к свойствам и методам другого объекта через цепочку прототипов. Каждый объект содержит внутреннюю ссылку на свой прототип, и если свойство не найдено в самом объекте, поиск продолжается в прототипе."
  },
  {
    "id": "js-022",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает prototype chain?",
    "answer": "Prototype chain — это механизм поиска свойств, при котором JavaScript сначала проверяет сам объект, затем его прототип, затем прототип прототипа и так далее до null. Поиск осуществляется через внутреннюю ссылку [[Prototype]], формируя цепочку наследования."
  },
  {
    "id": "js-023",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между __proto__ и prototype?",
    "answer": "prototype — это свойство функции-конструктора, которое используется для создания прототипа новых объектов. __proto__ — это ссылка объекта на его прототип (внутренний [[Prototype]]). При создании объекта через new, его __proto__ указывает на Function.prototype соответствующего конструктора."
  },
  {
    "id": "js-024",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает Object.create()?",
    "answer": "Object.create() создаёт новый объект с указанным прототипом. Первый аргумент функции становится прототипом создаваемого объекта. Этот метод позволяет вручную управлять prototype chain без использования конструктора и оператора new."
  },
  {
    "id": "js-025",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое constructor?",
    "answer": "Constructor — это функция, которая используется для создания объектов через оператор `new`.Когда вызывается `new`:) создаётся пустой объект;) ему устанавливается прототип из `constructor.prototype`;) вызывается функция-конструктор с this, указывающим на новый объект) если явно не возвращён объект — возвращается созданный экземпляр.У каждого объекта есть свойство `constructor`, указывающее на функцию, которая его создала если цепочка не была изменена."
  },
  {
    "id": "js-026",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое hasOwnProperty?",
    "answer": "hasOwnProperty — это метод объекта, который проверяет, принадлежит ли свойство самому объекту, а не получено через prototype chain. Это важно, потому что при переборе свойств, например через for...in, мы можем получить и унаследованные свойства. Поэтому hasOwnProperty позволяет отфильтровать только собственные свойства объекта."
  },
  {
    "id": "js-027",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между shallow copy и deep copy?",
    "answer": "Shallow copy копирует только первый уровень объекта, а вложенные объекты остаются ссылками. Deep copy создаёт полностью независимую копию со всеми вложенными структурами. Это важно при работе с иммутабельными данными, чтобы избежать случайной мутации исходного объекта."
  },
  {
    "id": "js-028",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает spread в объектах?",
    "answer": "Оператор spread (`...`) в объектах создаёт поверхностную копию свойств.\n\nОн перебирает **enumerable собственные свойства** объекта и копирует их в новый объект.\n\nВажно: spread делает **shallow copy**. Вложенные объекты не клонируются, а передаются по ссылке."
  },
  {
    "id": "js-029",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое enumerable свойства?",
    "answer": "Enumerable свойства — это свойства объекта, которые участвуют в переборе. Если у свойства флаг enumerable установлен в true, оно будет доступно через for...in или Object.keys(). Если false — свойство существует, но не отображается при переборе. Этот механизм используется для контроля видимости свойств при итерации."
  },
  {
    "id": "js-030",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое property descriptor?",
    "answer": "Property descriptor — это объект, который описывает настройки свойства объекта: его значение, возможность изменения, перечисления и удаления. Дескрипторы используются для тонкой настройки поведения свойств через Object.defineProperty(). В JavaScript каждое свойство имеет внутренние атрибуты, которые управляют его поведением, и именно их описывает property descriptor."
  },

   {
    "id": "js-031",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое замыкание?",
    "answer": "Замыкание — это механизм, при котором функция сохраняет доступ к переменным из своей лексической области видимости даже после завершения внешней функции. Это работает благодаря тому, что при создании функции в JavaScript формируется скрытая ссылка на её окружение. Замыкания активно используются для инкапсуляции, создания приватного состояния, фабрик функций и реализации модулей."
  },
  {
    "id": "js-032",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где замыкания реально используются?",
    "answer": "Замыкания используются для сохранения состояния и инкапсуляции данных. На практике это debounce/throttle, фабрики функций, модули, приватные переменные, частичное применение функций и вся логика хуков в React. Замыкание позволяет функции помнить своё лексическое окружение, поэтому можно строить более предсказуемые и изолированные абстракции без глобальных переменных."
  },
  {
    "id": "js-033",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Пример утечки памяти через замыкание?",
    "answer": "Утечка памяти через замыкание возникает, когда функция удерживает ссылки на объекты, которые логически уже не нужны, но остаются достижимыми через её лексическое окружение. Пока существует ссылка на эту функцию, сборщик мусора не освобождает захваченные данные. На практике это часто происходит при неправильной работе с обработчиками событий, таймерами или подписками, особенно в SPA. Решение — снимать обработчики, очищать таймеры и не замыкать лишние тяжёлые объекты."
  },
  {
    "id": "js-034",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое IIFE?",
    "answer": "IIFE (Immediately Invoked Function Expression) — это функция, которая создаётся и сразу же вызывается.\n\nПример концепции: функция оборачивается в скобки и тут же выполняется.\n\nИспользуется для создания изолированной области видимости и предотвращения загрязнения глобального пространства. До появления модулей это был основной способ изоляции кода."
  },
  {
    "id": "js-035",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое currying?",
    "answer": "Каррирование — это трансформация функции от нескольких аргументов в последовательность функций по одному аргументу. Оно основано на замыканиях, потому что каждый шаг сохраняет переданные значения в лексическом окружении. Используется для частичного применения, композиции функций и более декларативного функционального кода. В JavaScript каррирование часто применяется в функциональных утилитах и библиотеках вроде lodash или ramda."
  },
  {
    "id": "js-036",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое pure функция?",
    "answer": "Pure-функция — это детерминированная функция без побочных эффектов: она зависит только от входных аргументов и не изменяет внешнее состояние. Это делает код предсказуемым, тестируемым и безопасным для оптимизаций. В React, например, редьюсеры и компоненты по концепции должны быть чистыми, потому что это упрощает управление состоянием и ререндеры."
  },
  {
    "id": "js-037",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое memoization?",
    "answer": "Memoization — это оптимизационная техника, при которой результаты функции кэшируются на основе её аргументов. При повторном вызове с теми же параметрами возвращается сохранённое значение вместо повторного вычисления. Обычно реализуется через замыкание, где хранится cache. Это эффективно для детерминированных, чистых функций и активно используется в оптимизации вычислений и в React через useMemo и React.memo."
  },
  {
    "id": "js-038",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между rest и arguments?",
    "answer": "arguments — это устаревший array-like объект, доступный в обычных функциях, содержащий все переданные аргументы. Он не является настоящим массивом и не работает в стрелочных функциях. Rest-параметр (...args) — это современный синтаксис ES6, который собирает оставшиеся аргументы в настоящий массив. Он более предсказуемый, безопасный и рекомендуется к использованию вместо arguments."
  },
  {
    "id": "js-039",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое higher-order function?",
    "answer": "Higher-order function — это функция, которая оперирует другими функциями: принимает их как аргументы или возвращает их как результат. Это основа функционального программирования в JavaScript. Примеры — map, filter, reduce, а также кастомные утилиты вроде debounce, throttle, memoize. Такие функции позволяют строить более декларативный и переиспользуемый код."
  },
  {
    "id": "js-040",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как реализовать debounce?",
    "answer": "Debounce — это функция-обёртка, которая ограничивает частоту вызова переданной функции, откладывая её выполнение до тех пор, пока не пройдет определённый интервал без повторных вызовов. Реализуется через замыкание, где хранится ссылка на текущий таймер. При каждом новом вызове предыдущий таймер сбрасывается, что гарантирует выполнение только последнего вызова. Часто используется для оптимизации инпутов, resize, scroll и API-запросов."
  },
    {
    "id": "js-041",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "От чего зависит значение this?",
    "answer": "Значение this определяется способом вызова функции. В обычной функции оно устанавливается динамически: при вызове как метода объекта — это объект, при обычном вызове — глобальный объект или undefined в strict mode, при использовании call/apply/bind — явно заданное значение. В стрелочных функциях this лексический и берётся из внешней области видимости. То есть ключевой фактор — не объявление, а контекст вызова."
  },
  {
    "id": "js-042",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в стрелочной функции?",
    "answer": "Стрелочная функция не имеет собственного `this`. Она захватывает `this` из внешнего лексического окружения в момент создания. Её `this` нельзя изменить через `call`, `apply`, `bind` и нельзя использовать с `new`."
  },
  {
    "id": "js-043",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между call, apply и bind?",
    "answer": "Все три метода позволяют явно установить `this`. `call` — вызывает функцию сразу, аргументы передаются списком. `apply` — вызывает функцию сразу, аргументы передаются массивом. `bind` — возвращает новую функцию с привязанным `this`, но не вызывает её сразу."
  },
  {
    "id": "js-044",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что будет если вызвать метод без объекта?",
    "answer": "Если сохранить метод в переменную и вызвать отдельно, связь с объектом теряется. В strict mode `this` будет `undefined`, в обычном режиме — глобальный объект. Потому что при вызове нет объекта слева от точки."
  },
  {
    "id": "js-045",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое потеря контекста?",
    "answer": "Потеря контекста — это ситуация, когда метод объекта вызывается отдельно и `this` перестаёт указывать на исходный объект. Чаще всего происходит при передаче метода как callback."
  },
  {
    "id": "js-046",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как исправить потерю контекста?",
    "answer": "Основные способы: 1) Использовать `bind`. Обернуть вызов в стрелочную функцию. В классе — привязать метод в конструкторе. Самый универсальный способ — `bind`."
  },
  {
    "id": "js-047",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что будет если использовать new с bind?",
    "answer": "Если использовать new с функцией, созданной через bind, то привязанный через bind this игнорируется, потому что оператор new создаёт новый объект и устанавливает его в качестве контекста. Однако частично переданные аргументы через bind сохраняются. При этом прототипная цепочка остаётся корректной, и экземпляр всё равно будет instanceof исходной функции."
  },
  {
    "id": "js-048",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в class?",
    "answer": "В class значение this определяется способом вызова метода. В конструкторе this — это создаваемый экземпляр через new. Методы класса находятся в прототипе и получают this динамически при вызове как метода объекта. Если метод передать отдельно, контекст теряется. Для сохранения контекста часто используют стрелочные функции в полях класса, так как у них лексический this. По сути, class — это синтаксический сахар над прототипным наследованием, и поведение this остаётся тем же, что и в функциях-конструкторах."
  },
  {
    "id": "js-049",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в strict mode?",
    "answer": "В строгом режиме ('use strict') this в обычных функциях, вызванных напрямую, становится undefined вместо глобального объекта. Это предотвращает случайное изменение глобального состояния и делает поведение this более предсказуемым. Методы объектов и стрелочные функции продолжают работать по обычным правилам: контекст метода — объект, лексический this стрелок берётся из внешней области видимости."
  },
  {
    "id": "js-050",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему стрелочные функции нельзя использовать как конструктор?",
    "answer": "Стрелочные функции не могут использоваться как конструкторы, потому что они не создают собственного this и не имеют внутреннего [[Construct]] метода. При вызове через new возникает ошибка. Они предназначены для колбэков и внутренних функций, где важно сохранить лексическое this, а не для создания экземпляров объектов."
  },

  {
    "id": "js-051",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Event Loop?",
    "answer": "Event Loop — это цикл обработки событий в JavaScript, который позволяет однопоточному движку обрабатывать асинхронный код. Он управляет стеком вызовов и очередями задач: микрозадач (Promise, process.nextTick) и макрозадач (setTimeout, setInterval, I/O). Event Loop постоянно проверяет стек: если он пуст, берёт следующую задачу из очереди и выполняет её. Благодаря этому JavaScript может работать с асинхронными операциями без многопоточности."
  },
  {
    "id": "js-052",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между microtask и macrotask?",
    "answer": "Microtask — это асинхронная задача, которая выполняется сразу после текущего стека вызовов и перед макротасками. Типичные примеры: Promise.then, queueMicrotask, process.nextTick. Macrotask — это задача, которая ставится в очередь на выполнение после того, как стек пуст и завершены все микротаски. Примеры: setTimeout, setInterval, I/O события. Разница важна для понимания порядка выполнения асинхронного кода и оптимизации работы приложения."
  },
  {
    "id": "js-053",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где выполняется Promise?",
    "answer": "Promise состоит из двух частей: синхронной и асинхронной. Конструктор new Promise выполняется сразу в текущем стеке, что позволяет вычислить начальные значения и вызвать resolve/reject. Все .then/.catch/.finally — это микротаски, которые ставятся в очередь микрозадач Event Loop и выполняются после завершения текущего синхронного кода. Такой механизм обеспечивает предсказуемый порядок асинхронных операций и последовательность их выполнения."
  },
  {
    "id": "js-054",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему Promise выполняется раньше setTimeout?",
    "answer": "Promise выполняется раньше setTimeout, потому что его .then колбэки ставятся в очередь микротасок, которая обрабатывается сразу после завершения текущего стека вызовов. setTimeout ставит колбэк в очередь макротасок, которая обрабатывается только после того, как стек пуст и очередь микротасок очищена. Этот механизм Event Loop обеспечивает детерминированный порядок асинхронного кода: микротаски имеют приоритет над макротасками."
  },
  {
    "id": "js-055",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое callback hell?",
    "answer": "Callback hell — это ситуация, когда асинхронные операции вложены друг в друга через колбэки, образуя «лестницу». Код становится трудно читаемым, сложным для поддержки и обработки ошибок. Promise и async/await были созданы как решение этой проблемы."
  },
  {
    "id": "js-056",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Promise?",
    "answer": "Promise — это объект, представляющий результат асинхронной операции. Он может находиться в трёх состояниях: pending (ожидание) fulfilled (выполнен успешно) rejected (ошибка) Promise позволяет обрабатывать результат через `then`, `catch`, `finally`."
  },
  {
    "id": "js-057",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Promise chaining?",
    "answer": "Promise chaining — это практика последовательного вызова .then на Promise, где результат предыдущего шага автоматически передаётся следующему. Это позволяет строить последовательные асинхронные операции без глубокой вложенности колбэков. Если на любом шаге возвращается другой Promise, цепочка ожидает его разрешения, что делает код более читаемым и предсказуемым."
  },
  {
    "id": "js-058",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что произойдёт если не вернуть promise в then?",
    "answer": "Если внутри .then не возвращается Promise, цепочка продолжает работу сразу, передавая в следующий .then либо возвращённое значение, либо undefined. При возвращении обычного значения оно автоматически оборачивается в resolved Promise. Для асинхронных операций важно возвращать Promise, чтобы сохранить порядок выполнения и корректно ожидать результата в цепочке."
  },
  {
    "id": "js-059",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое async/await?",
    "answer": "async/await — это современный синтаксис для работы с асинхронными операциями в JavaScript, основанный на промисах. async обозначает функцию, которая всегда возвращает Promise, а await приостанавливает выполнение функции до разрешения промиса, не блокируя основной поток. Это делает код более читаемым и линейным, позволяет использовать try/catch для обработки ошибок и облегчает последовательное выполнение асинхронных операций."
  },
  {
    "id": "js-060",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как обрабатывать ошибки в async/await?",
    "answer": "В async/await обработка ошибок выполняется через try/catch. Любой отклонённый Promise внутри await выбрасывает исключение, которое можно перехватить блоком catch. Это позволяет писать асинхронный код с линейной логикой и управлять ошибками так же, как в синхронном коде, в отличие от .then/.catch, где обработка разбросана по цепочке. Альтернативные подходы — Promise.allSettled или обёртки, возвращающие кортеж [err, data] для удобного контроля ошибок без исключений."
  },
   {
    "id": "js-061",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что выполняется раньше: setTimeout или Promise?",
    "answer": "Promise выполняется раньше setTimeout, потому что его колбэки .then/.catch/.finally ставятся в очередь микротасок, которая обрабатывается сразу после завершения текущего стека вызовов. setTimeout ставит колбэк в очередь макротасок, которая обрабатывается только после очистки всех микротасок. Этот приоритет микротасок над макротасками — ключевой механизм Event Loop для предсказуемого порядка асинхронного кода."
  },
  {
    "id": "js-062",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где выполняется requestAnimationFrame?",
    "answer": "`requestAnimationFrame` выполняется перед следующим перерисовыванием кадра браузером.\n\nОн попадает в специальную очередь, которая обрабатывается перед repaint.\n\nИспользуется для анимаций, потому что синхронизируется с частотой обновления экрана."
  },
  {
    "id": "js-063",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает queueMicrotask?",
    "answer": "requestAnimationFrame выполняется на основном потоке браузера перед следующей перерисовкой кадра. Она ставит колбэк в очередь рендера, что позволяет синхронизировать анимацию с частотой обновления экрана. Это более эффективный способ обновлять DOM и Canvas по сравнению с setTimeout или setInterval, так как колбэк вызывается только тогда, когда браузер готов нарисовать новый кадр, и автоматически приостанавливается на неактивных вкладках."
  },
  {
    "id": "js-064",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Когда очищается call stack?",
    "answer": "Call stack — это структура данных, куда JavaScript помещает каждый вызов функции. Он очищается по мере завершения синхронного кода функции: после возврата значения или окончания выполнения функция снимается со стека. Когда стек пуст, Event Loop может перейти к обработке микротасок и макротасок. Понимание этого важно для дебага, рекурсии и асинхронного поведения JS."
  },
  {
    "id": "js-065",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Можно ли заблокировать event loop?",
    "answer": "Event Loop можно заблокировать только долгим синхронным кодом, потому что JS работает в одном потоке. Пока стек занят, Event Loop не может перейти к микротаскам и макротаскам. Это ключевой момент для понимания производительности и отклика приложения: тяжелые вычисления нужно выносить в Web Workers, setImmediate, Worker Threads или разбивать на части, чтобы не блокировать основной поток."
  },
  {
    "id": "js-066",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое starvation?",
    "answer": "Starvation — это ситуация, при которой задача или колбэк не получает возможности выполниться из-за непрерывной загрузки Event Loop другими задачами или длительным синхронным кодом. В JavaScript это может проявляться при бесконечных циклах, чрезмерном количестве микротасок или при блокирующем коде, что ведёт к «заморозке» интерфейса и задержке выполнения асинхронных операций."
  },
  {
    "id": "js-067",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Чем отличается setImmediate?",
    "answer": "setImmediate — это функция Node.js, которая ставит колбэк в очередь immediate callbacks, выполняемую после завершения текущего стека и перед очередью таймеров (setTimeout). Основное отличие от setTimeout(..., 0) — гарантированный приоритет над таймерами в том же Event Loop цикле. Она полезна для разделения тяжёлого синхронного кода на шаги без ожидания фактического времени таймера и для оптимизации работы Event Loop."
  },
  {
    "id": "js-068",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает fetch?",
    "answer": "fetch — это современный веб-API для HTTP-запросов, возвращающий Promise. При вызове fetch(url) создаётся асинхронная операция: JS не блокируется, а Event Loop продолжает работу. Promise резолвится объектом Response, который предоставляет методы для чтения тела запроса и доступа к статусу и заголовкам. Ошибки сети приводят к reject, но HTTP-ошибки нужно проверять через response.ok или response.status. fetch часто используется вместе с async/await для линейного и читаемого асинхронного кода."
  },
  {
    "id": "js-069",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему fetch не кидает ошибку при 404?",
    "answer": "fetch не бросает ошибку при HTTP-статусах вроде 404/500, потому что Promise резолвится, если сервер ответил и сеть сработала. Reject происходит только при сетевых ошибках или невозможности соединения. Чтобы корректно обрабатывать HTTP-ошибки, нужно проверять response.ok или response.status и при необходимости вручную выбрасывать исключение. Это ключевой момент, который отличает fetch от XMLHttpRequest, где ошибки статуса могли сразу приводить к ошибке."
  },
  {
    "id": "js-070",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое AbortController?",
    "answer": "AbortController — это современный API для отмены асинхронных операций, таких как fetch. Он создаёт объект контроллера с сигналом (signal), который передаётся в функцию. Вызов abort() прерывает операцию и вызывает AbortError в промисе. Этот механизм полезен для управления долгими или ненужными запросами, предотвращения утечек памяти и корректной очистки ресурсов в браузере."
  },
    {
    "id": "js-071",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между map и forEach?",
    "answer": "forEach — метод перебора массива для побочных действий, возвращает undefined. map — функциональный метод, который создаёт новый массив, где каждый элемент — результат вызова переданной функции на соответствующем элементе исходного массива. Основное отличие — наличие возвращаемого массива и возможность использовать цепочки методов (map().filter().reduce()), что делает map ключевым инструментом для декларативного функционального кода."
  },
  {
    "id": "js-072",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "filter возвращает новый массив?",
    "answer": "filter — это метод массива, который создаёт новый массив, включающий только те элементы исходного массива, которые удовлетворяют условию, заданному функцией-предикатом. Он не изменяет исходный массив, что позволяет безопасно работать с данными в функциональном стиле."
  },
  {
    "id": "js-073",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое reduce?",
    "answer": "reduce — это метод массива для свёртки всех элементов в одно значение. Он принимает функцию обратного вызова (accumulator, currentValue) и необязательное начальное значение. На каждом шаге аккумулятор обновляется результатом выполнения функции. reduce позволяет реализовывать суммирование, подсчёт, группировку, преобразование массивов в объекты и другие агрегирующие операции в функциональном стиле."
  },
  {
    "id": "js-074",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает sort?",
    "answer": "sort работает «странно» с числами без функции сравнения, потому что стандартное поведение — сортировка по строковому представлению элементов (Unicode). Для чисел и других кастомных критериев нужно передавать функцию сравнения (a, b) => a - b, которая возвращает отрицательное, положительное число или 0 для определения порядка элементов. Это важное различие, которое часто вызывает ошибки у новичков."
  },
  {
    "id": "js-075",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему sort работает странно с числами?",
    "answer": "По умолчанию `sort` сравнивает элементы как строки.\n\nНапример, `[1, 2, 10]` станет `[1, 10, 2]`, потому что строки сравниваются посимвольно.\n\nЧтобы корректно сортировать числа, нужно передать функцию сравнения: `(a, b) => a - b`."
  },
  {
    "id": "js-076",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как удалить дубликаты из массива?",
    "answer": "Для удаления дубликатов из массива можно использовать Set, который хранит только уникальные значения, или filter с проверкой индекса первого вхождения. Первый вариант наиболее эффективен для примитивов: [...new Set(arr)]. Второй вариант полезен, если нужны сложные условия или поддержка более сложных структур данных. Оба подхода создают новый массив, исходный не изменяя."
  },
  {
    "id": "js-077",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между slice и splice?",
    "answer": "Коротко: slice не меняет массив, просто возвращает часть его как новый массив. splice меняет массив на месте, удаляя, добавляя или заменяя элементы. Проще: slice — «срезать» копию, splice — «вырезать и вставить» прямо в оригинал."
  },
  {
    "id": "js-078",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает flat?",
    "answer": "flat — это метод массива, который создаёт новый массив, разворачивая вложенные массивы на заданное количество уровней (depth). Он не изменяет исходный массив. Используется для нормализации структур данных, когда элементы могут быть вложены, и требуется одномерный массив для дальнейшей обработки."
  },
  {
    "id": "js-079",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое immutable операции?",
    "answer": "Immutable операции — это способы работы с данными, при которых исходный объект или массив не изменяется, а создаётся новый объект/массив с необходимыми изменениями. Это помогает предотвращать побочные эффекты, делает код предсказуемым и безопасным для управления состоянием, особенно в UI-фреймворках и функциональном стиле программирования."
  },
  {
    "id": "js-080",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает find?",
    "answer": "`find` возвращает первый элемент массива, который удовлетворяет условию. Если элемент не найден, возвращается undefined. В отличие от `filter`, `find` останавливается после первого совпадения."
  },

    {
    "id": "js-081",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое destructuring?",
    "answer": "Destructuring — это синтаксис ES6, позволяющий деструктурировать объекты и массивы, присваивая их свойства или элементы переменным в удобной форме. Это улучшает читаемость кода, сокращает количество повторяющихся ссылок на свойства и позволяет легко задавать значения по умолчанию или переименовывать переменные."
  },
  {
    "id": "js-082",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое default parameters?",
    "answer": "Default parameters — это синтаксис ES6, позволяющий задавать значения аргументов функции по умолчанию прямо в сигнатуре. Если аргумент не передан или равен undefined, используется значение по умолчанию. Это упрощает код, уменьшает количество проверок внутри функции и повышает читаемость."
  },
  {
    "id": "js-083",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое optional chaining?",
    "answer": "Optional chaining — это современный синтаксис JavaScript (ES2020), который позволяет безопасно обращаться к вложенным свойствам, элементам массивов или вызывать методы объектов, даже если часть цепочки равна null или undefined. Он предотвращает выброс TypeError, возвращая undefined при отсутствии значения, и делает код компактным и читаемым, особенно при работе с динамическими или неполными данными."
  },
  {
    "id": "js-084",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое nullish coalescing?",
    "answer": "Nullish coalescing (??) — это оператор ES2020, который возвращает первый операнд, если он не null и не undefined, иначе возвращает второй. Он полезен для задания значений по умолчанию без ложных срабатываний на 0, false или пустую строку, что делает его более безопасным по сравнению с оператором логического ИЛИ (||)."
  },
  {
    "id": "js-085",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Symbol?",
    "answer": "Symbol — это примитив ES6, создающий уникальные значения, которые можно использовать как ключи объектов. Символы гарантируют уникальность и помогают избегать конфликтов имен свойств. Они не отображаются при обычной итерации, что делает их удобными для скрытых или системных свойств объектов, а также для метапрограммирования и создания кастомных интерфейсов, совместимых с встроенными механизмами, например, Symbol.iterator."
  },
  {
    "id": "js-086",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое iterator?",
    "answer": "Iterator — это объект с методом next(), который возвращает { value, done }, и позволяет последовательно перебирать коллекции. Все стандартные коллекции, реализующие Symbol.iterator, поддерживают перебор через for...of. Итераторы — фундаментальный механизм для создания собственных перебираемых объектов, генераторов и работы с последовательностями данных в JavaScript."
  },
  {
    "id": "js-087",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое generator?",
    "answer": "Generator — это функция, которая возвращает итератор, позволяющий последовательно получать значения с помощью yield. Она может приостанавливать выполнение и возобновляться по вызову next(), что позволяет строить ленивые вычисления, управлять асинхронными потоками и реализовывать пользовательские итераторы. Генераторы создаются с помощью function* и дают больше контроля над процессом перебора по сравнению с обычными функциями."
  },
  {
    "id": "js-088",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между for...in и for...of?",
    "answer": "for...in перебирает перечисляемые свойства объекта (ключи), включая индексы массива. for...of перебирает значения итерируемых объектов (arrays, strings, Map, Set, generators). Главное отличие: for...in возвращает ключи, а for...of — значения; for...of не работает на обычных объектах без Symbol.iterator. Это ключевое понимание для правильного выбора цикла в JavaScript."
  },
  {
    "id": "js-089",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Set?",
    "answer": "Set — это встроенная коллекция JavaScript, которая хранит уникальные значения любого типа. Она предоставляет методы для добавления (add), удаления (delete), проверки наличия (has) и очистки (clear) элементов. Set часто используется для удаления дубликатов из массивов, хранения уникальных идентификаторов и эффективного перебора элементов, так как автоматически гарантирует уникальность без дополнительной логики."
  },
  {
    "id": "js-090",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Map?",
    "answer": "Map — это встроенная коллекция JavaScript для хранения пар ключ–значение с ключами любого типа. Она обеспечивает точное хранение и быстрый доступ к элементам, сохраняет порядок добавления и предоставляет удобные методы (set, get, has, delete, clear) для управления данными. Map часто используют там, где нужны объекты в качестве ключей или предсказуемый порядок перебора элементов."
  },
  {
    "id": "js-091",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между CommonJS и ES Modules?",
    "answer": "CommonJS — это система модулей Node.js с require и module.exports, которая работает синхронно и подходит для серверного окружения. ES Modules (ESM) — стандарт ES6 с import/export, поддерживаемый браузерами и Node.js, позволяет статический анализ, tree-shaking и асинхронную загрузку модулей. Основные различия: способ импорта/экспорта, синхронность, поддержка tree-shaking, совместимость с браузером."
  },
  {
    "id": "js-092",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое tree shaking?",
    "answer": "Tree shaking — это оптимизация сборщика, который исключает неиспользуемый экспорт из итогового бандла. Она работает с ES Modules, потому что их импорты и экспорты статически анализируются, позволяя определить, что реально используется. Это уменьшает размер фронтенд-бандла и ускоряет загрузку страницы."
  },
  {
    "id": "js-093",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Можно ли импортировать динамически?",
    "answer": "Динамический импорт — это синтаксис import(), позволяющий загружать модули асинхронно по требованию. Он возвращает Promise, что позволяет подгружать код только тогда, когда он реально нужен (lazy-loading). В отличие от статического import, динамический можно использовать внутри функций, условий и событий, что помогает оптимизировать фронтенд-приложения."
  },
  {
    "id": "js-094",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Когда выполняется код модуля?",
    "answer": "Код ES модуля выполняется только один раз при первом импортировании, а результат сохраняется в кэше. Все последующие импорты получают уже выполненный модуль, что позволяет разделять состояние между файлами и предотвращает повторное выполнение кода. Это ключевой аспект поведения модулей в JavaScript и важен для понимания зависимостей и побочных эффектов."
  },
  {
    "id": "js-095",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое top-level await?",
    "answer": "Top-level await — это возможность использовать await не внутри функции, а на верхнем уровне ES модуля. При этом модуль «ждёт» завершения промиса перед выполнением остальных импортов. Это упрощает загрузку данных на старте приложения и позволяет писать асинхронный код в модулях более линейно. Важно помнить, что работает только в модулях, а не в скриптах CommonJS или обычных <script> в браузере."
  },
  {
    "id": "js-096",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает garbage collector?",
    "answer": "Garbage Collector — это встроенный механизм управления памятью в JavaScript, который автоматически отслеживает объекты и освобождает память, когда они становятся недостижимыми (нет ссылок на них из кода). Основной принцип — достижимость: если объект недостижим от корневых точек, он считается «мусором» и подлежит удалению. Это позволяет программистам не управлять памятью вручную, но важно помнить о замыканиях и глобальных ссылках, которые могут удерживать память и вызывать утечки."
  },
  {
    "id": "js-097",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое WeakMap?",
    "answer": "WeakMap — это структура данных, похожая на Map, где ключи слабые и могут быть удалены сборщиком мусора, если на объект больше нет ссылок. Она используется для хранения приватных данных или метаданных объектов без риска утечек памяти, и не поддерживает перебор элементов, что подчеркивает её цель — безопасное, «невидимое» для цикла хранения информации о объектах."
  },
  {
    "id": "js-098",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему WeakMap не итерируется?",
    "answer": "WeakMap — это структура данных, похожая на Map, где ключи слабые и могут быть удалены сборщиком мусора, если на объект больше нет ссылок. Она используется для хранения приватных данных или метаданных объектов без риска утечек памяти, и не поддерживает перебор элементов, что подчеркивает её цель — безопасное, «невидимое» для цикла хранения информации о объектах."
  },
  {
    "id": "js-099",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Proxy?",
    "answer": "Proxy — это встроенный объект JavaScript, позволяющий создавать перехватчики операций с объектом. Он оборачивает исходный объект и через «ловушки» (get, set, apply, deleteProperty и др.) позволяет контролировать чтение, запись, вызовы функций и другие действия. Proxy полезен для валидации данных, логирования, создания реактивных объектов и прокси-сервисов, которые расширяют поведение исходного объекта без изменения его структуры."
  },
  {
    "id": "js-100",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Reflect?",
    "answer": "Reflect — это объект ES6, предоставляющий методы для унифицированного доступа и управления объектами (get, set, has, deleteProperty, apply и др.). Он особенно полезен при работе с Proxy: позволяет вызывать стандартное поведение объекта внутри ловушек, избегая дублирования логики, а также обеспечивает чистый и консистентный способ метапрограммирования."
  }
]

