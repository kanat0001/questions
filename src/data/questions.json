[

  {
    "id": "js-001",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между var, let и const?",
    "answer": "В JavaScript переменные можно объявлять через `var`, `let` и `const`, но они отличаются областью видимости, hoisting и правилами повторного объявления.\n\n- **`var`** — имеет **функциональную область видимости** (не блочную). При hoisting объявление поднимается вверх и **сразу инициализируется `undefined`**, поэтому к переменной можно обратиться до строки объявления, но получишь `undefined`. Разрешает **переобъявление в той же области**, из-за чего легко словить баги.\n\n- **`let`** — имеет **блочную область видимости**. Тоже поднимается (hoisting есть), но до инициализации находится в **TDZ**, поэтому обращение до строки объявления даст **ReferenceError**. **Повторно объявить нельзя**, но **переназначать значение можно**.\n\n- **`const`** — как `let` по scope и TDZ, но **нельзя переназначить ссылку**. При этом **объекты/массивы можно мутировать**, потому что меняется содержимое, а не ссылка."
  },
  {
    "id": "js-002",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Temporal Dead Zone?",
    "answer": "Temporal Dead Zone (TDZ) — это промежуток времени в пределах блока, когда переменная `let/const` уже **создана** (движок знает о ней), но ещё **не инициализирована**.\n\nПроще: с начала блока `{ ... }` и до строки, где выполнится `let a = ...`, переменная `a` находится в TDZ. Если попытаться обратиться к ней в этот момент, будет **ReferenceError**.\n\nTDZ существует, чтобы предотвратить использование переменной «до объявления» и сделать код предсказуемее (в отличие от `var`, который даёт `undefined`)."
  },
  {
    "id": "js-003",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое hoisting и что именно хойстится?",
    "answer": "Hoisting — это не «магия перемещения строк», а результат того, что движок JavaScript сначала **создаёт контекст выполнения** (creation phase), а уже потом выполняет код.\n\nНа фазе создания движок заранее регистрирует объявления:\n\n- **`var`**: объявление поднимается и **инициализируется `undefined`**.\n- **`let/const`**: объявление поднимается, но **не инициализируется** — поэтому доступ до строки объявления запрещён (TDZ).\n- **`function declaration`**: поднимается **полностью**, поэтому функцию можно вызвать до её объявления.\n- **`function expression`**: сама функция не хойстится как declaration — хойстится только переменная (и то по правилам `var/let/const`)."
  },
  {
    "id": "js-004",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между function declaration и function expression?",
    "answer": "Разница в том, *когда* функция становится доступной и *как* она создаётся.\n\n- **Function Declaration** (`function foo(){}`) — создаётся на фазе **creation** и **хойстится полностью**. Поэтому её можно вызывать до строки объявления. Это часть «структуры» программы.\n\n- **Function Expression** (`const foo = function(){}`) — функция создаётся **в момент выполнения**, когда исполнится выражение присваивания. До этого `foo` либо в TDZ (если `let/const`), либо `undefined` (если `var`).\n\nНа практике expression часто удобнее, потому что она ведёт себя как обычное значение (можно передавать/возвращать/создавать условно), но declaration полезна для читаемости и when you need hoisting."
  },
  {
    "id": "js-005",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему функции — объекты?",
    "answer": "В JavaScript функция — это **объект особого типа**, который можно не только хранить и передавать, но ещё и **вызывать**.\n\nЭто видно по поведению:\n- у функции можно создавать **свойства** (как у объекта);\n- у неё есть встроенные методы вроде `call`, `apply`, `bind`;\n- функцию можно передавать как аргумент и возвращать из другой функции;\n- у обычной функции есть `prototype` (используется при `new`).\n\nПоэтому корректно говорить: функция в JS — это *callable object*."
  },
  {
    "id": "js-006",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое область видимости (scope)?",
    "answer": "Scope — это правило, которое определяет, **где переменная доступна**.\n\nВ JavaScript scope **лексический**, то есть зависит от того, *где переменная объявлена в коде*, а не от того, откуда функция была вызвана.\n\nОсновные виды:\n- **Global scope** — доступно везде.\n- **Function scope** — переменные внутри функции (и `var` тоже сюда относится).\n- **Block scope** — переменные внутри `{}` (это `let/const`).\n\nИдея простая: переменная живёт и доступна внутри своей области и всех вложенных областей."
  },
  {
    "id": "js-007",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое lexical environment?",
    "answer": "Lexical Environment — это внутренняя «таблица» движка, которая хранит:\n1) **переменные текущей области** (Environment Record),\n2) **ссылку на внешнюю область** (Outer Lexical Environment).\n\nКогда код обращается к переменной, движок сначала смотрит в текущий lexical environment. Если не находит — идёт по ссылке наружу. Именно на этом построены **scope chain** и **замыкания**.\n\nВажно: это не объект, который ты видишь в коде — это внутренняя структура движка."
  },
  {
    "id": "js-008",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что хранится в call stack?",
    "answer": "Call stack — это стек, в котором движок хранит **контексты выполнения** (execution contexts) функций.\n\nКогда вызывается функция:\n- создаётся её execution context (локальные переменные, параметры, `this`, ссылка на внешний scope);\n- этот контекст кладётся наверх стека.\n\nКогда функция заканчивает работу — её контекст снимается со стека.\n\nСтек работает по принципу **LIFO** (последний вошёл — первый вышел). Именно поэтому бесконечная рекурсия приводит к `Maximum call stack size exceeded`."
  },
  {
    "id": "js-009",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает цепочка областей видимости (scope chain)?",
    "answer": "Scope chain — это механизм поиска переменных через связку lexical environments.\n\nАлгоритм такой:\n1) движок ищет переменную в **текущем scope**;\n2) если не находит — идёт во **внешний scope** (outer lexical environment);\n3) повторяет, пока не дойдёт до global scope;\n4) если нигде нет — получаем **ReferenceError**.\n\nКлючевой момент: цепочка scope формируется *по месту объявления* (лексически). То есть функция «помнит», где она была создана, и ищет переменные именно там."
  },
  {
    "id": "js-010",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему typeof null === \"object\"?",
    "answer": "Это историческая особенность JavaScript (по сути баг), которая тянется с самых ранних версий языка.\n\nВ первых реализациях значения имели внутренние «теги» типов, и у `null` оказался тег, который совпал с `object`. Поэтому оператор `typeof` возвращает \"object\".\n\nИсправить это нельзя без поломки огромного количества старого кода, поэтому поведение закрепили ради обратной совместимости."
  },
  {
    "id": "js-011",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Какие есть примитивные типы в JavaScript?",
    "answer": "В JavaScript есть 7 примитивных типов данных:\n\n- `string`\n- `number`\n- `bigint`\n- `boolean`\n- `undefined`\n- `symbol`\n- `null`\n\nПримитивы — это неизменяемые значения. Они хранятся напрямую, а не по ссылке. В отличие от объектов, примитив не имеет свойств (но временно оборачивается в объект при обращении к методам, например у строки)."
  },
  {
    "id": "js-012",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое boxing?",
    "answer": "Boxing — это процесс временного оборачивания примитива в объект-обёртку.\n\nНапример, когда мы пишем `\"hello\".length`, строка временно превращается в объект `String`, чтобы можно было вызвать метод. После выполнения операции объект удаляется.\n\nСуществуют обёртки: `String`, `Number`, `Boolean`. Обычно boxing происходит автоматически и незаметно."
  },
  {
    "id": "js-013",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между == и ===?",
    "answer": "`===` — строгое сравнение. Сравнивает и тип, и значение.\n\n`==` — нестрогое сравнение. Перед сравнением выполняет неявное приведение типов (type coercion).\n\nНапример:\n`5 === \"5\"` → false\n`5 == \"5\"` → true\n\nНа практике рекомендуется использовать `===`, чтобы избежать неожиданных преобразований."
  },
  {
    "id": "js-014",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое неявное приведение типов?",
    "answer": "Неявное приведение типов (type coercion) — это автоматическое преобразование одного типа в другой во время выполнения операций.\n\nОно происходит, например, при использовании `==`, математических операторов или конкатенации строк.\n\nПример:\n`\"5\" - 1` → 4 (строка преобразуется в число)\n`\"5\" + 1` → \"51\" (число преобразуется в строку)\n\nВажно понимать правила coercion, чтобы избежать неожиданных результатов."
  },
  {
    "id": "js-015",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что вернет [] + {} и почему?",
    "answer": "`[] + {}` вернёт строку `\"[object Object]\"`.\n\nОператор `+` с объектами приводит их к примитиву через `toString()`.\n\n- `[]` преобразуется в пустую строку `\"\"`.\n- `{}` преобразуется в `\"[object Object]\"`.\n\nВ итоге происходит строковая конкатенация: `\"\" + \"[object Object]\"`."
  },
  {
    "id": "js-016",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что вернет {} + []?",
    "answer": "Результат зависит от контекста.\n\nВ большинстве случаев в консоли браузера `{}` интерпретируется как пустой блок кода, а не объект. Тогда выражение фактически становится `+[]`, что даёт 0.\n\n`[]` приводится к `\"\"`, затем к числу 0.\n\nЕсли же принудительно рассматривать `{}` как объект (например, в скобках), результат будет таким же, как и в предыдущем случае — строковая конкатенация."
  },
  {
    "id": "js-017",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему NaN !== NaN?",
    "answer": "`NaN` означает \"Not a Number\" и по стандарту IEEE 754 считается не равным ничему, включая самого себя.\n\nПоэтому `NaN === NaN` возвращает false.\n\nЭто сделано для обозначения некорректного числового результата, а не конкретного значения."
  },
  {
    "id": "js-018",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как правильно проверить значение на NaN?",
    "answer": "Лучший способ — использовать `Number.isNaN()`.\n\n`Number.isNaN(value)` возвращает true только если значение действительно является `NaN`.\n\nГлобальная функция `isNaN()` сначала приводит значение к числу, поэтому может дать неожиданный результат. Например, `isNaN(\"text\")` → true, а `Number.isNaN(\"text\")` → false."
  },
  {
    "id": "js-019",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между null и undefined?",
    "answer": "`undefined` означает, что значение не было присвоено.\n\n`null` — это явное указание на \"отсутствие значения\".\n\n`undefined` чаще возникает автоматически (неинициализированная переменная, отсутствующий аргумент).\n`null` обычно присваивается вручную.\n\nИнтересно, что `typeof null` возвращает \"object\" (историческая особенность), а `typeof undefined` — \"undefined\"."
  },
  {
    "id": "js-020",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое falsy значения?",
    "answer": "Falsy — это значения, которые приводятся к `false` в логическом контексте.\n\nВ JavaScript их всего 7:\n- `false`\n- `0`\n- `-0`\n- `0n`\n- `\"\"` (пустая строка)\n- `null`\n- `undefined`\n- `NaN`\n\nВсе остальные значения считаются truthy.\n\nВажно помнить это при проверках в `if`, чтобы не допустить логических ошибок."
  },

   {
    "id": "js-021",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое prototype?",
    "answer": "Prototype — это механизм наследования в JavaScript.\n\nКаждый объект в JS имеет скрытую ссылку на другой объект — свой **прототип**. Если у объекта нет нужного свойства, движок ищет его в прототипе.\n\nУ функций есть специальное свойство `prototype`, которое используется при создании объектов через `new`. Этот объект становится прототипом созданного экземпляра.\n\nПроще: prototype — это способ передавать общие свойства и методы всем экземплярам."
  },
  {
    "id": "js-022",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает prototype chain?",
    "answer": "Prototype chain — это цепочка поиска свойств через прототипы.\n\nАлгоритм такой:\n1) движок ищет свойство в самом объекте;\n2) если не находит — переходит к его прототипу (`[[Prototype]]`);\n3) затем к прототипу прототипа;\n4) и так до `null`.\n\nЕсли нигде не найдено — возвращается `undefined`.\n\nИменно эта цепочка обеспечивает наследование в JavaScript."
  },
  {
    "id": "js-023",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между __proto__ и prototype?",
    "answer": "`prototype` — это свойство **функции-конструктора**. Оно определяет, какой объект станет прототипом для экземпляров, созданных через `new`.\n\n`__proto__` — это ссылка конкретного объекта на его прототип.\n\nПроще:\n- `prototype` есть у функций.\n- `__proto__` есть у объектов.\n\nТехнически `__proto__` — это геттер/сеттер для внутреннего `[[Prototype]]`. Использовать его напрямую не рекомендуется — лучше применять `Object.getPrototypeOf()` и `Object.setPrototypeOf()`."
  },
  {
    "id": "js-024",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает Object.create()?",
    "answer": "`Object.create(proto)` создаёт новый объект и устанавливает его прототипом объект `proto`.\n\nТо есть мы вручную задаём, от какого объекта будет наследование.\n\nПример: можно создать объект без прототипа через `Object.create(null)`.\n\nЭто низкоуровневый способ создания объектов без использования `new`."
  },
  {
    "id": "js-025",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое constructor?",
    "answer": "Constructor — это функция, которая используется для создания объектов через оператор `new`.\n\nКогда вызывается `new`:\n1) создаётся пустой объект;\n2) ему устанавливается прототип из `constructor.prototype`;\n3) вызывается функция-конструктор с `this`, указывающим на новый объект;\n4) если явно не возвращён объект — возвращается созданный экземпляр.\n\nУ каждого объекта есть свойство `constructor`, указывающее на функцию, которая его создала (если цепочка не была изменена)."
  },
  {
    "id": "js-026",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое hasOwnProperty?",
    "answer": "`hasOwnProperty()` — это метод, который проверяет, принадлежит ли свойство самому объекту, а не его прототипу.\n\nПример: если метод унаследован через prototype, `hasOwnProperty` вернёт false.\n\nЭто важно, когда нужно отличить собственные свойства от унаследованных."
  },
  {
    "id": "js-027",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между shallow copy и deep copy?",
    "answer": "**Shallow copy (поверхностная копия)** копирует только первый уровень свойств. Если внутри есть объекты — копируется ссылка.\n\n**Deep copy (глубокая копия)** рекурсивно копирует все вложенные объекты.\n\nПример shallow: `{ ...obj }` или `Object.assign()`.\n\nВажно: при shallow copy изменения вложенных объектов повлияют на оригинал."
  },
  {
    "id": "js-028",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает spread в объектах?",
    "answer": "Оператор spread (`...`) в объектах создаёт поверхностную копию свойств.\n\nОн перебирает **enumerable собственные свойства** объекта и копирует их в новый объект.\n\nВажно: spread делает **shallow copy**. Вложенные объекты не клонируются, а передаются по ссылке."
  },
  {
    "id": "js-029",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое enumerable свойства?",
    "answer": "Enumerable свойства — это свойства объекта, которые участвуют в перечислении (например, в `for...in` или `Object.keys()`).\n\nПо умолчанию свойства, созданные через обычное присваивание, являются enumerable.\n\nНекоторые встроенные свойства (например методы в prototype) обычно не enumerable."
  },
  {
    "id": "js-030",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое property descriptor?",
    "answer": "Property descriptor — это объект, описывающий характеристики свойства.\n\nОн может содержать:\n- `value` — значение\n- `writable` — можно ли изменять\n- `enumerable` — участвует ли в перечислении\n- `configurable` — можно ли изменить настройки\n- `get` / `set` — для accessor-свойств\n\nПолучить descriptor можно через `Object.getOwnPropertyDescriptor()`.\n\nОн позволяет точно контролировать поведение свойства."
  },

   {
    "id": "js-031",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое замыкание?",
    "answer": "Замыкание — это функция, которая запоминает лексическое окружение, в котором была создана.\n\nЭто значит, что даже после завершения внешней функции внутренняя функция продолжает иметь доступ к её переменным.\n\nЗамыкание возникает каждый раз, когда функция создаётся внутри другой функции и использует внешние переменные."
  },
  {
    "id": "js-032",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где замыкания реально используются?",
    "answer": "Замыкания используются для:\n\n- создания приватных переменных;\n- сохранения состояния между вызовами;\n- фабрик функций;\n- работы с асинхронностью (setTimeout, обработчики событий);\n- реализации memoization и debounce.\n\nФактически замыкания — это фундаментальный механизм работы React-хуков и большинства функциональных паттернов."
  },
  {
    "id": "js-033",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Пример утечки памяти через замыкание?",
    "answer": "Утечка возникает, если замыкание удерживает ссылку на большой объект, который больше не нужен.\n\nНапример: если обработчик события замыкает DOM-элемент или большой массив, и этот обработчик не удаляется, сборщик мусора не сможет освободить память.\n\nПроблема не в замыкании как таковом, а в том, что оно удерживает ссылки на данные, которые могли бы быть удалены."
  },
  {
    "id": "js-034",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое IIFE?",
    "answer": "IIFE (Immediately Invoked Function Expression) — это функция, которая создаётся и сразу же вызывается.\n\nПример концепции: функция оборачивается в скобки и тут же выполняется.\n\nИспользуется для создания изолированной области видимости и предотвращения загрязнения глобального пространства. До появления модулей это был основной способ изоляции кода."
  },
  {
    "id": "js-035",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое currying?",
    "answer": "Currying — это преобразование функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент.\n\nВместо `fn(a, b, c)` получаем `fn(a)(b)(c)`.\n\nЭто позволяет частично применять аргументы и создавать более специализированные функции."
  },
  {
    "id": "js-036",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое pure функция?",
    "answer": "Pure функция — это функция, которая:\n\n1) всегда возвращает одинаковый результат при одинаковых входных данных;\n2) не имеет побочных эффектов (не изменяет внешние переменные, DOM, состояние).\n\nТакие функции предсказуемы и проще тестируются."
  },
  {
    "id": "js-037",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое memoization?",
    "answer": "Memoization — это техника оптимизации, при которой результат функции сохраняется, чтобы при повторном вызове с теми же аргументами не выполнять вычисления заново.\n\nРаботает через замыкание: создаётся кэш, который хранит результаты предыдущих вызовов."
  },
  {
    "id": "js-038",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между rest и arguments?",
    "answer": "`arguments` — это псевдомассив всех переданных аргументов (доступен только в обычных функциях, не в стрелочных).\n\n`rest` (`...args`) — это современный синтаксис, который собирает аргументы в настоящий массив.\n\nRest предпочтительнее, потому что он более предсказуем и поддерживает методы массива."
  },
  {
    "id": "js-039",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое higher-order function?",
    "answer": "Higher-order function — это функция, которая:\n\n- принимает другую функцию как аргумент, или\n- возвращает функцию.\n\nПримеры: `map`, `filter`, `reduce`.\n\nЭто основа функционального программирования в JavaScript."
  },
  {
    "id": "js-040",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как реализовать debounce?",
    "answer": "Debounce — это функция-обёртка, которая откладывает выполнение до тех пор, пока не пройдёт заданное время без новых вызовов.\n\nРаботает через замыкание и `setTimeout`: при каждом вызове предыдущий таймер очищается, и запускается новый.\n\nИспользуется для оптимизации ввода в поиске, resize-событий и других частых вызовов."
  },
    {
    "id": "js-041",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "От чего зависит значение this?",
    "answer": "Значение `this` определяется способом вызова функции, а не местом её объявления.\n\nОсновные правила:\n1) Обычный вызов — `this` равен `undefined` в strict mode или глобальному объекту вне strict mode.\n2) Вызов как метода — `this` указывает на объект слева от точки.\n3) Через `call`, `apply`, `bind` — `this` равен переданному объекту.\n4) При `new` — `this` указывает на создаваемый экземпляр.\n5) В стрелочных функциях — `this` берётся из внешнего лексического окружения."
  },
  {
    "id": "js-042",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в стрелочной функции?",
    "answer": "Стрелочная функция не имеет собственного `this`.\n\nОна захватывает `this` из внешнего лексического окружения в момент создания.\n\nЕё `this` нельзя изменить через `call`, `apply`, `bind` и нельзя использовать с `new`."
  },
  {
    "id": "js-043",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между call, apply и bind?",
    "answer": "Все три метода позволяют явно установить `this`.\n\n- `call` — вызывает функцию сразу, аргументы передаются списком.\n- `apply` — вызывает функцию сразу, аргументы передаются массивом.\n- `bind` — возвращает новую функцию с привязанным `this`, но не вызывает её сразу."
  },
  {
    "id": "js-044",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что будет если вызвать метод без объекта?",
    "answer": "Если сохранить метод в переменную и вызвать отдельно, связь с объектом теряется.\n\nВ strict mode `this` будет `undefined`, в обычном режиме — глобальный объект.\n\nПотому что при вызове нет объекта слева от точки."
  },
  {
    "id": "js-045",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое потеря контекста?",
    "answer": "Потеря контекста — это ситуация, когда метод объекта вызывается отдельно и `this` перестаёт указывать на исходный объект.\n\nЧаще всего происходит при передаче метода как callback."
  },
  {
    "id": "js-046",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как исправить потерю контекста?",
    "answer": "Основные способы:\n\n1) Использовать `bind`.\n2) Обернуть вызов в стрелочную функцию.\n3) В классе — привязать метод в конструкторе.\n\nСамый универсальный способ — `bind`."
  },
  {
    "id": "js-047",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что будет если использовать new с bind?",
    "answer": "Если функция была привязана через `bind`, а затем вызвана с `new`, приоритет получает `new`.\n\nСоздаётся новый объект, и `this` указывает на него, игнорируя привязанный контекст."
  },
  {
    "id": "js-048",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в class?",
    "answer": "В class `this` работает как в функции-конструкторе.\n\nПри вызове через `new` он указывает на созданный экземпляр.\n\nМетоды класса не привязываются автоматически, поэтому возможна потеря контекста при передаче метода как callback."
  },
  {
    "id": "js-049",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает this в strict mode?",
    "answer": "В strict mode при обычном вызове функции `this` равен `undefined`.\n\nВ нестрогом режиме `this` в таком случае указывает на глобальный объект.\n\nStrict mode предотвращает неявную привязку к глобальному объекту."
  },
  {
    "id": "js-050",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему стрелочные функции нельзя использовать как конструктор?",
    "answer": "Стрелочные функции не имеют собственного `this` и `prototype`.\n\nУ них отсутствует внутренний метод `[[Construct]]`, поэтому вызов через `new` приведёт к ошибке.\n\nОни предназначены для сохранения лексического `this`, а не для создания экземпляров."
  },

  {
    "id": "js-051",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Event Loop?",
    "answer": "Event Loop — это механизм, который управляет выполнением асинхронного кода в JavaScript.\n\nJavaScript однопоточный, поэтому сначала выполняется весь синхронный код (call stack). Когда стек пуст, Event Loop берёт задачи из очередей и помещает их в стек.\n\nОн обеспечивает неблокирующее выполнение через очереди macrotask и microtask."
  },
  {
    "id": "js-052",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Разница между microtask и macrotask?",
    "answer": "Macrotask — это задачи вроде `setTimeout`, `setInterval`, `setImmediate`.\n\nMicrotask — это задачи из `Promise.then`, `catch`, `finally`, `queueMicrotask`.\n\nПосле выполнения текущего синхронного кода сначала полностью очищается очередь microtask, и только потом выполняется следующая macrotask."
  },
  {
    "id": "js-053",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где выполняется Promise?",
    "answer": "Колбэки `then`, `catch`, `finally` выполняются в очереди microtask.\n\nСам executor внутри `new Promise()` выполняется синхронно, а обработчики результата — асинхронно через microtask."
  },
  {
    "id": "js-054",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему Promise выполняется раньше setTimeout?",
    "answer": "Потому что обработчики Promise попадают в очередь microtask.\n\nEvent Loop сначала очищает всю очередь microtask, и только потом берёт следующую macrotask (например `setTimeout`).\n\nПоэтому `Promise.then` всегда выполнится раньше `setTimeout(..., 0)`."
  },
  {
    "id": "js-055",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое callback hell?",
    "answer": "Callback hell — это ситуация, когда асинхронные операции вложены друг в друга через колбэки, образуя «лестницу».\n\nКод становится трудно читаемым, сложным для поддержки и обработки ошибок.\n\nPromise и async/await были созданы как решение этой проблемы."
  },
  {
    "id": "js-056",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Promise?",
    "answer": "Promise — это объект, представляющий результат асинхронной операции.\n\nОн может находиться в трёх состояниях:\n- pending (ожидание)\n- fulfilled (выполнен успешно)\n- rejected (ошибка)\n\nPromise позволяет обрабатывать результат через `then`, `catch`, `finally`."
  },
  {
    "id": "js-057",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Promise chaining?",
    "answer": "Promise chaining — это последовательное выполнение асинхронных операций через возврат значения или нового Promise внутри `then`.\n\nКаждый `then` возвращает новый Promise, что позволяет строить цепочки без вложенности.\n\nЭто делает код линейным и читаемым."
  },
  {
    "id": "js-058",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что произойдёт если не вернуть promise в then?",
    "answer": "Если внутри `then` не вернуть Promise или значение, следующий `then` получит `undefined`.\n\nЕсли запустить асинхронную операцию внутри `then`, но не вернуть её, цепочка не будет ждать её завершения.\n\nЭто частая ошибка, из-за которой нарушается порядок выполнения."
  },
  {
    "id": "js-059",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое async/await?",
    "answer": "`async/await` — это синтаксический сахар над Promise.\n\nФункция с `async` всегда возвращает Promise.\n\n`await` приостанавливает выполнение функции до тех пор, пока Promise не завершится, и возвращает его результат.\n\nЭто делает асинхронный код похожим на синхронный."
  },
  {
    "id": "js-060",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как обрабатывать ошибки в async/await?",
    "answer": "Ошибки обрабатываются через `try/catch` внутри async-функции.\n\nЕсли Promise внутри `await` будет отклонён (rejected), управление перейдёт в блок `catch`.\n\nТакже можно обрабатывать ошибки на уровне вызова через `.catch()`."
  },
   {
    "id": "js-061",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что выполняется раньше: setTimeout или Promise?",
    "answer": "Promise выполнится раньше.\n\nОбработчики `Promise.then` попадают в очередь **microtask**, а `setTimeout` — в очередь **macrotask**.\n\nПосле выполнения текущего синхронного кода Event Loop сначала полностью очищает очередь microtask, и только потом берёт следующую macrotask.\n\nПоэтому `Promise.then` всегда выполняется раньше `setTimeout(..., 0)`."
  },
  {
    "id": "js-062",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Где выполняется requestAnimationFrame?",
    "answer": "`requestAnimationFrame` выполняется перед следующим перерисовыванием кадра браузером.\n\nОн попадает в специальную очередь, которая обрабатывается перед repaint.\n\nИспользуется для анимаций, потому что синхронизируется с частотой обновления экрана."
  },
  {
    "id": "js-063",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает queueMicrotask?",
    "answer": "`queueMicrotask` добавляет функцию в очередь microtask.\n\nОна выполнится после текущего синхронного кода, но раньше любой macrotask.\n\nЭто низкоуровневый способ добавить задачу в ту же очередь, что и `Promise.then`."
  },
  {
    "id": "js-064",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Когда очищается call stack?",
    "answer": "Call stack очищается, когда завершается выполнение текущей функции.\n\nКогда стек становится пустым, Event Loop может взять следующую задачу из очереди.\n\nЕсли стек никогда не освобождается (например бесконечный цикл), асинхронные задачи не выполняются."
  },
  {
    "id": "js-065",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Можно ли заблокировать event loop?",
    "answer": "Да. Если выполнить долгий синхронный код (например тяжёлый цикл или рекурсию), call stack будет занят.\n\nПока стек не освободится, Event Loop не сможет обрабатывать очереди задач.\n\nЭто приводит к «зависанию» интерфейса."
  },
  {
    "id": "js-066",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое starvation?",
    "answer": "Starvation — это ситуация, когда одни задачи не получают выполнение из-за постоянного добавления других задач с более высоким приоритетом.\n\nНапример, если бесконечно добавлять microtask, macrotask могут долго не выполняться.\n\nЭто проблема баланса очередей в Event Loop."
  },
  {
    "id": "js-067",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Чем отличается setImmediate?",
    "answer": "`setImmediate` — это API, доступный в Node.js (и некоторых средах), которое ставит задачу в очередь, выполняемую после текущей фазы I/O.\n\nВ браузерах его обычно нет.\n\nПо смыслу он ближе к macrotask, но порядок выполнения отличается от `setTimeout` в зависимости от среды."
  },
  {
    "id": "js-068",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает fetch?",
    "answer": "`fetch` отправляет HTTP-запрос и возвращает Promise.\n\nСам запрос выполняется в среде браузера (Web APIs), а не в call stack.\n\nКогда ответ получен, результат помещается в очередь microtask через Promise.\n\n`fetch` всегда возвращает Promise, даже при ошибках HTTP."
  },
  {
    "id": "js-069",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему fetch не кидает ошибку при 404?",
    "answer": "`fetch` считает ошибкой только сетевые сбои (например отсутствие соединения).\n\nHTTP-статусы вроде 404 или 500 — это корректный ответ сервера, поэтому Promise считается успешно выполненным.\n\nЧтобы проверить ошибку, нужно анализировать `response.ok` или `response.status`."
  },
  {
    "id": "js-070",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое AbortController?",
    "answer": "`AbortController` — это объект, который позволяет отменять асинхронные операции, например `fetch`.\n\nСоздаётся контроллер, его `signal` передаётся в запрос, и при вызове `abort()` операция прерывается.\n\nИспользуется для отмены запросов при размонтировании компонентов или смене страницы."
  },
    {
    "id": "js-071",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между map и forEach?",
    "answer": "`map` создаёт и возвращает новый массив, применяя функцию к каждому элементу.\n\n`forEach` просто выполняет функцию для каждого элемента и ничего не возвращает (undefined).\n\n`map` используется для преобразования данных, а `forEach` — когда нужно выполнить побочное действие."
  },
  {
    "id": "js-072",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "filter возвращает новый массив?",
    "answer": "Да. `filter` всегда возвращает новый массив.\n\nОн проходит по массиву и добавляет в новый массив только те элементы, для которых функция возвращает true.\n\nОригинальный массив при этом не изменяется."
  },
  {
    "id": "js-073",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое reduce?",
    "answer": "`reduce` — это метод, который сворачивает массив к одному значению.\n\nОн принимает функцию-аккумулятор и начальное значение.\n\nНа каждой итерации возвращённое значение становится новым аккумулятором.\n\nИспользуется для суммирования, группировки, преобразования в объект и других операций."
  },
  {
    "id": "js-074",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает sort?",
    "answer": "`sort` сортирует массив на месте (мутирует его).\n\nПо умолчанию элементы преобразуются в строки и сравниваются по Unicode.\n\nМожно передать функцию сравнения `(a, b) => a - b`, чтобы задать числовую или пользовательскую сортировку."
  },
  {
    "id": "js-075",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему sort работает странно с числами?",
    "answer": "По умолчанию `sort` сравнивает элементы как строки.\n\nНапример, `[1, 2, 10]` станет `[1, 10, 2]`, потому что строки сравниваются посимвольно.\n\nЧтобы корректно сортировать числа, нужно передать функцию сравнения: `(a, b) => a - b`."
  },
  {
    "id": "js-076",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как удалить дубликаты из массива?",
    "answer": "Самый простой способ — использовать `Set`, который хранит только уникальные значения.\n\nПример концепции: создать Set из массива и затем преобразовать его обратно в массив.\n\nТакже можно использовать `filter` или `reduce`, но Set — самый лаконичный способ."
  },
  {
    "id": "js-077",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между slice и splice?",
    "answer": "`slice` возвращает новый массив и не изменяет оригинальный.\n\n`splice` изменяет исходный массив: может удалять, добавлять или заменять элементы.\n\n`slice` — безопасная операция, `splice` — мутирующая."
  },
  {
    "id": "js-078",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что делает flat?",
    "answer": "`flat` создаёт новый массив, «разворачивая» вложенные массивы на указанную глубину.\n\nПо умолчанию глубина равна 1.\n\nМетод не мутирует исходный массив."
  },
  {
    "id": "js-079",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое immutable операции?",
    "answer": "Immutable операции — это операции, которые не изменяют исходные данные, а возвращают новые.\n\nПримеры: `map`, `filter`, `slice`, spread.\n\nОни важны в функциональном программировании и в React, где состояние должно обновляться без мутаций."
  },
  {
    "id": "js-080",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает find?",
    "answer": "`find` возвращает первый элемент массива, который удовлетворяет условию.\n\nЕсли элемент не найден, возвращается undefined.\n\nВ отличие от `filter`, `find` останавливается после первого совпадения."
  },

    {
    "id": "js-081",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое destructuring?",
    "answer": "Destructuring — это синтаксис, позволяющий извлекать значения из массивов или объектов и присваивать их переменным.\n\nДля массивов — по позиции.\nДля объектов — по имени свойства.\n\nПозволяет писать более краткий и читаемый код, особенно при работе с параметрами функций."
  },
  {
    "id": "js-082",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое default parameters?",
    "answer": "Default parameters — это значения по умолчанию для параметров функции.\n\nЕсли аргумент не передан или равен `undefined`, используется значение по умолчанию.\n\nЭто избавляет от необходимости вручную проверять аргументы внутри функции."
  },
  {
    "id": "js-083",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое optional chaining?",
    "answer": "Optional chaining (`?.`) позволяет безопасно обращаться к вложенным свойствам объекта.\n\nЕсли промежуточное значение равно `null` или `undefined`, выражение возвращает `undefined` вместо ошибки.\n\nУдобно при работе с вложенными структурами данных."
  },
  {
    "id": "js-084",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое nullish coalescing?",
    "answer": "Nullish coalescing (`??`) возвращает правое значение, если левое равно `null` или `undefined`.\n\nВ отличие от `||`, он не считает falsy-значения вроде 0 или пустую строку поводом для замены.\n\nИспользуется для безопасного задания значений по умолчанию."
  },
  {
    "id": "js-085",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Symbol?",
    "answer": "Symbol — это примитивный тип данных, создающий уникальное значение.\n\nДаже если создать два Symbol с одинаковым описанием, они будут разными.\n\nЧасто используется для создания уникальных ключей объектов, чтобы избежать конфликтов."
  },
  {
    "id": "js-086",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое iterator?",
    "answer": "Iterator — это объект, который реализует метод `next()`.\n\nМетод `next()` возвращает объект вида `{ value, done }`.\n\nИтераторы позволяют поэлементно обходить коллекции. Они лежат в основе цикла `for...of`."
  },
  {
    "id": "js-087",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое generator?",
    "answer": "Generator — это специальная функция, которая может приостанавливать выполнение с помощью `yield`.\n\nОна возвращает итератор.\n\nПри каждом вызове `next()` выполнение продолжается до следующего `yield`.\n\nПозволяет управлять последовательностью выполнения."
  },
  {
    "id": "js-088",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между for...in и for...of?",
    "answer": "`for...in` перебирает ключи (имена свойств) объекта.\n\n`for...of` перебирает значения и работает только с итерируемыми объектами (массивы, строки, Set, Map).\n\nДля массивов обычно используют `for...of`, а не `for...in`."
  },
  {
    "id": "js-089",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Set?",
    "answer": "Set — это коллекция уникальных значений.\n\nОн автоматически удаляет дубликаты и поддерживает методы `add`, `delete`, `has`.\n\nПолезен для работы с уникальными элементами."
  },
  {
    "id": "js-090",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Map?",
    "answer": "Map — это коллекция пар ключ-значение.\n\nВ отличие от обычного объекта, ключами могут быть любые значения (включая объекты).\n\nMap сохраняет порядок добавления элементов и имеет методы `set`, `get`, `has`, `delete`."
  },
  {
    "id": "js-091",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "В чем разница между CommonJS и ES Modules?",
    "answer": "CommonJS используется в Node.js (require / module.exports), а ES Modules — современный стандарт (import / export).\n\nОсновные различия:\n\n- CommonJS загружает модули синхронно.\n- ES Modules работают статически: import анализируется до выполнения кода.\n- ES Modules поддерживают tree shaking.\n- В ES Modules `this` в верхнем уровне равен undefined.\n\nСегодня ES Modules — стандарт в браузере и современном Node."
  },
  {
    "id": "js-092",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое tree shaking?",
    "answer": "Tree shaking — это удаление неиспользуемого кода при сборке проекта.\n\nРаботает благодаря статической структуре ES Modules: сборщик может определить, какие экспорты не используются, и убрать их из итогового бандла.\n\nЭто уменьшает размер финального файла."
  },
  {
    "id": "js-093",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Можно ли импортировать динамически?",
    "answer": "Да. В ES Modules существует динамический импорт через `import()`.\n\nОн возвращает Promise и позволяет загружать модуль во время выполнения.\n\nИспользуется для ленивой загрузки (code splitting)."
  },
  {
    "id": "js-094",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Когда выполняется код модуля?",
    "answer": "Код ES-модуля выполняется один раз при первом импорте.\n\nПосле этого модуль кэшируется, и повторные импорты используют уже выполненную версию.\n\nImport обрабатывается до выполнения остального кода файла."
  },
  {
    "id": "js-095",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое top-level await?",
    "answer": "Top-level await позволяет использовать `await` прямо в модуле, вне async-функции.\n\nПри этом выполнение модуля приостанавливается до завершения Promise.\n\nИспользуется для инициализации данных до загрузки приложения."
  },
  {
    "id": "js-096",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Как работает garbage collector?",
    "answer": "Современные движки используют алгоритм mark-and-sweep.\n\n1) От корневых объектов (global, стек) помечаются достижимые объекты.\n2) Недостижимые объекты удаляются.\n\nОбъект удаляется, если на него больше нет ссылок.\n\nЗамыкания могут удерживать ссылки и препятствовать освобождению памяти."
  },
  {
    "id": "js-087",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое WeakMap?",
    "answer": "WeakMap — это коллекция ключ-значение, где ключами могут быть только объекты.\n\nГлавная особенность — ключи хранятся \"слабо\". Если на объект больше нет других ссылок, он может быть удалён сборщиком мусора.\n\nИспользуется для хранения приватных данных, связанных с объектами."
  },
  {
    "id": "js-098",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Почему WeakMap не итерируется?",
    "answer": "WeakMap не поддерживает перебор (нет методов keys, values, entries), потому что его ключи могут быть удалены сборщиком мусора в любой момент.\n\nЕсли бы перебор был возможен, поведение коллекции стало бы непредсказуемым."
  },
  {
    "id": "js-099",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Proxy?",
    "answer": "Proxy — это объект-обёртка, который позволяет перехватывать операции над другим объектом.\n\nМожно перехватывать чтение, запись, удаление свойств, вызовы функций и другие действия.\n\nИспользуется для валидации, реактивности, логирования и создания фреймворков."
  },
  {
    "id": "js-100",
    "topicId": "js",
    "topicTitle": "JS",
    "question": "Что такое Reflect?",
    "answer": "Reflect — это встроенный объект с методами для работы с объектами (get, set, defineProperty и др.).\n\nОн дублирует низкоуровневые операции JavaScript, но в виде функций.\n\nЧасто используется вместе с Proxy, чтобы корректно передавать операции оригинальному объекту."
  },
  {
    "id": "dom-003",
    "topicId": "dom",
    "topicTitle": "DOM / Events",
    "question": "innerHTML vs innerText vs textContent: разница и безопасность?",
    "answer": "innerHTML — вставка HTML, риск XSS.\ninnerText — видимый текст, может быть медленнее (учёт CSS).\ntextContent — весь текст, быстрее, безопаснее для вставки текста.\nПравило: нужен текст → textContent; нужен HTML → innerHTML осознанно.",
    "tags": ["dom", "xss"]
  },
  {
    "id": "dom-004",
    "topicId": "dom",
    "topicTitle": "DOM / Events",
    "question": "Позиционирование: static/relative/absolute/fixed/sticky — в чём смысл?",
    "answer": "static — обычный поток.\nrelative — в потоке, можно смещать; якорь для absolute.\nabsolute — вне потока, относительно ближайшего position != static (или документа).\nfixed — относительно окна.\nsticky — как relative, но «прилипает» после порога.",
    "tags": ["css", "position"]
  },
  {
    "id": "events-001",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "Event bubbling: что это и зачем нужно?",
    "answer": "Событие всплывает от целевого элемента к родителям. Даёт делегирование событий и уменьшает количество обработчиков.",
    "tags": ["events", "bubbling"]
  },
  {
    "id": "events-002",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "Event capturing: что это и фазы событий?",
    "answer": "Capturing идёт сверху вниз до target, затем target phase, затем bubbling снизу вверх. Capturing используют реже, но важно знать модель фаз.",
    "tags": ["events", "capturing"]
  },
  {
    "id": "events-003",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "stopPropagation vs stopImmediatePropagation — разница?",
    "answer": "stopPropagation останавливает дальнейшее распространение по DOM, но другие обработчики на этом же элементе продолжат.\nstopImmediatePropagation останавливает и распространение, и остальные обработчики на этом элементе.",
    "tags": ["events"]
  },
  {
    "id": "events-004",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "preventDefault: что отменяет и чем отличается от stopPropagation?",
    "answer": "preventDefault отменяет стандартное действие браузера (переход по ссылке, submit формы и т.д.).\nstopPropagation — про распространение события по DOM.",
    "tags": ["events"]
  },
  {
    "id": "events-005",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "this в event handler: обычная функция vs стрелка?",
    "answer": "Обычная функция: this часто указывает на элемент, на котором висит handler.\nСтрелка: this берётся из внешнего контекста, обычно не DOM-элемент → частая путаница.",
    "tags": ["events", "this"]
  },
  {
    "id": "events-006",
    "topicId": "events",
    "topicTitle": "DOM Events",
    "question": "Event delegation: что это и почему важно?",
    "answer": "Один обработчик на родителе вместо множества на детях. Основано на bubbling. Плюсы: меньше памяти, работает с динамическими элементами, проще логика списков/таблиц.",
    "tags": ["events", "delegation"]
  },

  {
    "id": "perf-001",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "async vs defer: в чём разница и что чаще используют для основного JS?",
    "answer": "async: загрузка параллельно, выполняется сразу после загрузки, порядок не гарантирован.\ndefer: загрузка параллельно, выполняется после парсинга HTML, порядок сохраняется.\nОбычно основной JS — defer.",
    "tags": ["html", "scripts"]
  },
  {
    "id": "perf-002",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "LocalStorage vs SessionStorage — отличия и ограничения?",
    "answer": "LocalStorage живёт долго и доступен во всех вкладках одного origin.\nSessionStorage живёт в рамках вкладки и очищается при закрытии.\nОба: синхронные, хранят строки, не для чувствительных данных.",
    "tags": ["storage"]
  },
  {
    "id": "perf-003",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "Ограничения browser storage и риски безопасности?",
    "answer": "Обычно 5–10MB на origin. Доступ только в рамках origin. Данные легко смотреть в DevTools. storage доступен из JS → при XSS можно украсть.",
    "tags": ["storage", "security"]
  },
  {
    "id": "perf-004",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "Cookie vs Storage: ключевой вывод выбора для auth и состояния?",
    "answer": "Cookie — часть HTTP и уходят с каждым запросом; есть HttpOnly/Secure/SameSite → подходят для auth.\nStorage — не отправляется автоматически, проще, но уязвим к XSS.\nВывод: auth → cookie, клиентское состояние → storage.",
    "tags": ["cookies", "storage", "auth"]
  },
  {
    "id": "perf-005",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "Почему важно чистить listeners и intervals в SPA?",
    "answer": "Если не снять listener/не очистить interval — остаются ссылки → GC не освобождает память, логика работает «в никуда», возможны утечки и лишняя нагрузка.",
    "tags": ["memory-leak", "spa"]
  },
  {
    "id": "perf-006",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "ResizeObserver: что решает и почему тоже нужно отключать?",
    "answer": "Следит за изменениями размеров конкретного элемента (не только окна). Полезен для адаптивных компонентов и динамических layout. Observer нужно отключать, иначе лишние вычисления/утечки.",
    "tags": ["browser", "observer"]
  },
  {
    "id": "perf-007",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "IntersectionObserver: зачем и где применяют?",
    "answer": "Отслеживает появление/исчезновение элемента в viewport/контейнере. Кейс: lazy loading, бесконечный скролл, аналитика видимости. Нужно отключать при ненадобности.",
    "tags": ["browser", "observer"]
  },
  {
    "id": "perf-008",
    "topicId": "perf",
    "topicTitle": "Storage / Performance",
    "question": "Web Vitals: LCP/CLS/INP — что измеряют и от чего страдают?",
    "answer": "LCP — скорость появления крупнейшего элемента (картинки, блокирующий JS, медленный сервер).\nCLS — «прыжки» layout (картинки без размеров, динамический контент, шрифты).\nINP — отзывчивость на действия (long tasks, тяжёлые handlers, перегруз main thread).",
    "tags": ["performance", "web-vitals"]
  },

  {
    "id": "css-001",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "CSS Box Model: из чего состоит и типичная ошибка с width/height?",
    "answer": "content + padding + border + margin. Типичная ошибка: задать width и добавить padding/border → элемент станет больше ожидаемого.",
    "tags": ["css", "box-model"]
  },
  {
    "id": "css-002",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "box-sizing: border-box — что меняет и почему его ставят глобально?",
    "answer": "border-box включает padding и border в width/height → размеры предсказуемы, меньше багов верстки. Поэтому часто задают глобально.",
    "tags": ["css", "box-sizing"]
  },
  {
    "id": "css-003",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Центрирование: почему нет одного универсального способа?",
    "answer": "Нужно понять контекст: по горизонтали/вертикали, один элемент/группа, внутри блока/страницы. Часто решают flex/grid/margin auto.",
    "tags": ["css", "layout"]
  },
  {
    "id": "css-004",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Flexbox: ключевая идея и ограничение?",
    "answer": "Модель распределения по одной оси (главная/поперечная). Отлично для выравнивания и адаптивных рядов/колонок. Для двухмерных сеток лучше Grid.",
    "tags": ["css", "flexbox"]
  },
  {
    "id": "css-005",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "CSS Grid: чем отличается от flexbox и когда лучше?",
    "answer": "Grid — двухмерная сетка (строки и колонки одновременно) и управление структурой layout. Flexbox — одна ось и выравнивание. Часто используются вместе.",
    "tags": ["css", "grid"]
  },
  {
    "id": "css-006",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Responsive layout: идея и инструменты?",
    "answer": "Адаптация под разные экраны без отдельной «мобильной версии»: гибкие размеры, media queries, flex/grid, относительные единицы. Важно: не только ширина, но устройства/ориентации/плотность пикселей.",
    "tags": ["css", "responsive"]
  },
  {
    "id": "css-007",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "px vs em vs rem — когда что использовать?",
    "answer": "px — абсолютная, предсказуемая, но хуже масштабируется.\nem — от font-size родителя (может «накапливаться»).\nrem — от корневого font-size, удобно масштабировать весь интерфейс.\nПрактика: rem для UI, em локально, px точечно.",
    "tags": ["css", "units"]
  },
  {
    "id": "css-008",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Семантическая вёрстка: зачем и примеры тегов?",
    "answer": "HTML про структуру и смысл, CSS про внешний вид. Семантика улучшает доступность, SEO и поддержку. Примеры: header/footer/main/section/article/nav/aside.",
    "tags": ["html", "semantic"]
  },
  {
    "id": "css-009",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "CSS prefixes: что это и почему сейчас редко пишут руками?",
    "answer": "Вендорные префиксы для экспериментальных свойств (-webkit-, -moz-...). Сейчас редко вручную: стабильнее стандарты, а префиксы обычно добавляет сборка.",
    "tags": ["css", "prefixes"]
  },
  {
    "id": "css-010",
    "topicId": "css",
    "topicTitle": "CSS / Layout",
    "question": "Autoprefixer: что делает и от чего зависит?",
    "answer": "Автоматически добавляет нужные CSS-префиксы на этапе сборки, ориентируясь на целевые браузеры (настройки поддержки).",
    "tags": ["css", "tooling"]
  },

  {
    "id": "tool-001",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "Bundlers (webpack/vite): зачем нужны и разница подхода dev/prod?",
    "answer": "Бандлер собирает модули в бандлы для браузера, трансформирует код, оптимизирует размер и ассеты.\nwebpack: классическая сборка заранее.\nvite: dev через native ESM, prod — сборка.",
    "tags": ["tooling", "bundler"]
  },
  {
    "id": "tool-002",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "Dev vs Prod сборка: ключевые различия?",
    "answer": "Dev: скорость разработки, неминифицировано, sourcemaps, быстрые пересборки.\nProd: производительность, минификация, tree-shaking, оптимизация ассетов, отключение dev-инструментов.",
    "tags": ["tooling", "build"]
  },
  {
    "id": "tool-003",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "Source maps: зачем и нюансы в продакшене?",
    "answer": "Показывают соответствие исходного и собранного кода для отладки и stack trace. В проде могут отключать/хранить отдельно — баланс удобства и безопасности/размера.",
    "tags": ["tooling", "sourcemaps"]
  },
  {
    "id": "tool-004",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "npm install vs npm ci — когда что?",
    "answer": "npm install читает package.json и может менять lock — удобно локально.\nnpm ci ставит строго по package-lock, не меняет его и чистит node_modules — идеально для CI и повторяемых сборок.",
    "tags": ["npm", "ci"]
  },
  {
    "id": "tool-005",
    "topicId": "tooling",
    "topicTitle": "Tooling / Git / CI",
    "question": "package-lock.json: зачем нужен и что фиксирует?",
    "answer": "Фиксирует точные версии всей зависимости цепочки. package.json — что разрешено, lock — что фактически установлено. Нужен для одинаковых версий у всех и воспроизводимых сборок.",
    "tags": ["npm", "lockfile"]
  },
  {
    "id": "git-001",
    "topicId": "git",
    "topicTitle": "Git",
    "question": "git fetch vs git pull — разница?",
    "answer": "fetch скачивает изменения и обновляет ссылки origin/*, но не меняет текущую ветку.\npull = fetch + merge/rebase и сразу применяет изменения к текущей ветке.",
    "tags": ["git"]
  },
  {
    "id": "git-002",
    "topicId": "git",
    "topicTitle": "Git",
    "question": "git merge vs git rebase — концептуальная разница и правило?",
    "answer": "merge создаёт merge-коммит и сохраняет историю ветвления (безопаснее для команды).\nrebase переписывает историю и делает её линейной (опасно на общих ветках).\nПравило: rebase локально, merge для общих веток.",
    "tags": ["git"]
  },
  {
    "id": "git-003",
    "topicId": "git",
    "topicTitle": "Git",
    "question": "Staging area (index): зачем нужен?",
    "answer": "Промежуточный слой: ты явно выбираешь, какие изменения попадут в коммит. Коммит берёт только то, что в staging. Это основа аккуратных коммитов и работы в команде.",
    "tags": ["git", "staging"]
  },
  {
    "id": "git-004",
    "topicId": "git",
    "topicTitle": "Git",
    "question": "Конфликты из-за EOL (LF vs CRLF): почему бывают и как решают (на уровне идеи)?",
    "answer": "Разные ОС/настройки дают разные концы строк → git видит «изменения» и конфликты. Решают единым форматом в проекте и настройками git/editor на нормализацию.",
    "tags": ["git", "eol"]
  },
  {
    "id": "ci-001",
    "topicId": "ci",
    "topicTitle": "CI/CD",
    "question": "CI/CD: что такое и разница Delivery vs Deployment?",
    "answer": "CI — автоматические сборки/тесты/линтеры при изменениях.\nCD — доставка/деплой. Delivery: код готов к выкладке (ручной шаг). Deployment: выкладывается автоматически.",
    "tags": ["ci", "cd"]
  }
]
